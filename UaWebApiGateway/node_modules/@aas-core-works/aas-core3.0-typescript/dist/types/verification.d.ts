/**
 * Verify that the instances of the meta-model satisfy the invariants.
 *
 * Here is an example how to verify an instance of {@link types.Extension}:
 *
 * ```ts
 * import * as AasTypes from "@aas-core-works/aas-core3.0-typescript/types";
 * import * as AasVerification from "@aas-core-works/aas-core3.0-typescript/verification";
 *
 * const anInstance = new AasTypes.Extension(
 *   // ... some constructor arguments ...
 * );
 *
 * for (const error of AasVerification.verify(anInstance)) {
 *   console.log(`${error.message} at: ${error.path}`);
 * }
 * ```
 */
import * as AasTypes from "./types";
/**
 * Represent a property access on a path to an erroneous value.
 */
export declare class PropertySegment {
    /**
     * Instance containing the property
     */
    readonly instance: AasTypes.Class;
    /**
     * Name of the property
     */
    readonly name: string;
    constructor(instance: AasTypes.Class, name: string);
    toString(): string;
}
/**
 * Represent an index access on a path to an erroneous value.
 */
export declare class IndexSegment {
    /**
     * Sequence containing the item at {@link index}
     */
    readonly sequence: Array<AasTypes.Class>;
    /**
     * Index of the item in the {@link sequence}
     */
    readonly index: number;
    constructor(sequence: Array<AasTypes.Class>, index: number);
    toString(): string;
}
export type Segment = PropertySegment | IndexSegment;
/**
 * Represent the relative path to the erroneous value.
 */
export declare class Path {
    readonly segments: Array<Segment>;
    prepend(segment: Segment): void;
    toString(): string;
}
/**
 * Represent a verification error in the data.
 */
export declare class VerificationError {
    /**
     * Human-readable description of the error
     */
    readonly message: string;
    /**
     * Path to the erroneous value
     */
    readonly path: Path;
    /**
     * Initialize with the given `message` and `path`.
     *
     * @remarks
     * If no `path` is specified, initialize with an empty path.
     */
    constructor(message: string, path?: Path | null);
}
/**
 * Check that `text` is a valid short ID.
 */
export declare function matchesIdShort(text: string): boolean;
/**
 * Check that `text` is a valid version string.
 */
export declare function matchesVersionType(text: string): boolean;
/**
 * Check that `text` is a valid revision string.
 */
export declare function matchesRevisionType(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:dateTime`.
 *
 * @remarks
 *
 * The time zone must be fixed to UTC. We verify only that the `text` matches
 * a pre-defined pattern. We *do not* verify that the day of month is
 * correct nor do we check for leap seconds.
 *
 * See: https://www.w3.org/TR/xmlschema-2/#dateTime
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsDateTimeUtc(text: string): boolean;
/**
 * Check that `value` is a valid `xs:dateTime` with
 * the time zone set to UTC.
 *
 * @param value - to be checked
 * @returns `true` if `value` is a valid `xs:dateTime` with the UTC time zone
 */
export declare function isXsDateTimeUtc(value: string): boolean;
/**
 * Check that `text` conforms to the pattern of MIME type.
 *
 * @remarks
 *
 * The definition has been taken from:
 * https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
 * https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
 * https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesMimeType(text: string): boolean;
/**
 * Check that `text` is a path conforming to the pattern of RFC 8089.
 *
 * @remarks
 *
 * The definition has been taken from:
 * https://datatracker.ietf.org/doc/html/rfc8089
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesRfc8089Path(text: string): boolean;
/**
 * Check that `text` is a valid BCP 47 language tag.
 *
 * @remarks
 *
 * See: https://en.wikipedia.org/wiki/IETF_language_tag
 */
export declare function matchesBcp47(text: string): boolean;
/**
 * Check that `langStrings` are specified each for a unique
 * language.
 *
 * @param langStrings - to be verified
 * @returns `true` if the check passes
 */
export declare function langStringsHaveUniqueLanguages(langStrings: Iterable<AasTypes.IAbstractLangString>): boolean;
/**
 * Check that there are no duplication {@link types.Qualifier.type}'s
 * in the `qualifiers`.
 *
 * @param qualifiers - to be verified
 * @returns `true` if the check passes
 */
export declare function qualifierTypesAreUnique(qualifiers: Iterable<AasTypes.Qualifier>): boolean;
/**
 * Check that `text` conforms to the pattern of the Constraint AASd-130.
 *
 * @remarks
 *
 * Ensures that encoding is possible and interoperability between different
 * serializations is possible.
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXmlSerializableString(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:anyURI`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#anyURI and
 * https://datatracker.ietf.org/doc/html/rfc3987
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsAnyUri(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:base64Binary`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#base64Binary
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsBase64Binary(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:boolean`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#boolean
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsBoolean(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:date`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#date
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsDate(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:dateTime`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#dateTime
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsDateTime(text: string): boolean;
/**
 * Check that `value` is a valid `xs:dateTime`.
 *
 * @remarks
 * Year 1 BCE is the last leap BCE year.
 * See https://www.w3.org/TR/xmlschema-2/#dateTime.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:dateTime`
 */
export declare function isXsDateTime(value: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:decimal`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#decimal
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsDecimal(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:double`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#double
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsDouble(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:duration`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#duration
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsDuration(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:float`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#float
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsFloat(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:gDay`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gDay
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsGDay(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:gMonth`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gMonth
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsGMonth(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:gMonthDay`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gMonthDay
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsGMonthDay(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:gYear`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gYear
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsGYear(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:gYearMonth`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gYearMonth
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsGYearMonth(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:hexBinary`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#hexBinary
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsHexBinary(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:time`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#time
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsTime(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:integer`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#integer
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsInteger(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:long`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#long
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsLong(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:int`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#int
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsInt(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:short`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#short
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsShort(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:byte`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#byte
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsByte(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:nonNegativeInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsNonNegativeInteger(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:positiveInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#positiveInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsPositiveInteger(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:unsignedLong`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedLong
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsUnsignedLong(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:unsignedInt`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedInt
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsUnsignedInt(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:unsignedShort`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedShort
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsUnsignedShort(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:unsignedByte`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedByte
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsUnsignedByte(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:nonPositiveInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsNonPositiveInteger(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:negativeInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#negativeInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsNegativeInteger(text: string): boolean;
/**
 * Check that `text` conforms to the pattern of an `xs:string`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#string
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export declare function matchesXsString(text: string): boolean;
/**
 * Check if `year` is a leap year.
 *
 * @remarks
 * Year 1 BCE is the last leap BCE year.
 * See https://www.w3.org/TR/xmlschema-2/#dateTime.
 *
 * @param year - to be checked
 * @returns `true` if `year` is a leap year.
 */
export declare function isLeapYear(year: number): boolean;
/**
 * Check that `value` is a valid `xs:date`.
 *
 * @remarks
 * Year 1 BCE is the last leap BCE year.
 * See https://www.w3.org/TR/xmlschema-2/#dateTime.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:date`
 */
export declare function isXsDate(value: string): boolean;
/**
 * Check that `value` is a valid `xs:double`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:double`
 */
export declare function isXsDouble(value: string): boolean;
/**
 * Check that `value` is a valid `xs:float`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:float`
 */
export declare function isXsFloat(value: string): boolean;
/**
 * Check that `value` is a valid `xs:gMonthDay`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:gMonthDay`
 */
export declare function isXsGMonthDay(value: string): boolean;
/**
 * Check that `value` is a valid `xs:long`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:long`
 */
export declare function isXsLong(value: string): boolean;
/**
 * Check that `value` is a valid `xs:int`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:int`
 */
export declare function isXsInt(value: string): boolean;
/**
 * Check that `value` is a valid `xs:short`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:short`
 */
export declare function isXsShort(value: string): boolean;
/**
 * Check that `value` is a valid `xs:byte`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:byte`
 */
export declare function isXsByte(value: string): boolean;
/**
 * Check that `value` is a valid `xs:unsignedLong`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedLong`
 */
export declare function isXsUnsignedLong(value: string): boolean;
/**
 * Check that `value` is a valid `xs:unsignedInt`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedInt`
 */
export declare function isXsUnsignedInt(value: string): boolean;
/**
 * Check that `value` is a valid `xs:unsignedShort`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedShort`
 */
export declare function isXsUnsignedShort(value: string): boolean;
/**
 * Check that `value` is a valid `xs:unsignedByte`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedByte`
 */
export declare function isXsUnsignedByte(value: string): boolean;
/**
 * Check that `value` is consistent with the given `valueType`.
 *
 * @param value - expected to be consistent with `valueType`
 * @param valueType - expected XSD type of `value`
 * @returns `true` if `value` consistent with `valueType`
 */
export declare function valueConsistentWithXsdType(value: string, valueType: AasTypes.DataTypeDefXsd): boolean;
/**
 * Check that the target of the model reference matches the `expectedType`.
 */
export declare function isModelReferenceTo(reference: AasTypes.Reference, expectedType: AasTypes.KeyTypes): boolean;
/**
 * Check that the target of the reference matches a {@link constants!AAS_REFERABLES}.
 */
export declare function isModelReferenceToReferable(reference: AasTypes.Reference): boolean;
/**
 * Check that all {@link types.IReferable.idShort}'s are unique
 * among `referables`.
 *
 * @param referables - to be verified
 * @returns `true` if the check passes
 */
export declare function idShortsAreUnique(referables: Iterable<AasTypes.IReferable>): boolean;
/**
 * Check that all {@link types.IReferable.idShort}'s are unique
 * among values of `inputVariables`, `outputVariables`
 * and `inoutputVariables`.
 *
 * @param inputVariables - to be verified
 * @param outputVariables - to be verified
 * @param inoutputVariables - to be verified
 * @returns `true` if the check passes
 */
export declare function idShortsOfVariablesAreUnique(inputVariables: Iterable<AasTypes.OperationVariable> | null, outputVariables: Iterable<AasTypes.OperationVariable> | null, inoutputVariables: Iterable<AasTypes.OperationVariable> | null): boolean;
/**
 * Check that all {@link types.Extension.name} are unique
 * among `extensions`.
 *
 * @param extensions - to be verified
 * @returns `true` if the check passes
 */
export declare function extensionNamesAreUnique(extensions: Iterable<AasTypes.Extension>): boolean;
/**
 * Check that all `elements` have the identical
 * {@link types.ISubmodelElement.semanticId}.
 *
 * @param elements - to be checked
 * @returns `true` if all the semantic IDs are identical
 */
export declare function submodelElementsHaveIdenticalSemanticIds(elements: Iterable<AasTypes.ISubmodelElement>): boolean;
/**
 * Check that `element` is an instance of class corresponding to
 * `expectedType`.
 *
 * @param element - to be checked for type
 * @param expectedType - in the check
 * @returns `true` if `element` corresponds to `expectedType`
 */
export declare function submodelElementIsOfType(element: AasTypes.ISubmodelElement, expectedType: AasTypes.AasSubmodelElements): boolean;
/**
 * Check that `elements` which are {@link types.Property} or {@link types.Range}
 * have the given `valueType`.
 *
 * @param elements - to be verified
 * @returns `true` if the check passes
 */
export declare function propertiesOrRangesHaveValueType(elements: Iterable<AasTypes.ISubmodelElement>, valueType: AasTypes.DataTypeDefXsd): boolean;
/**
 * Check that the two references, `that` and `other`,
 * are equal by comparing their {@link types.Reference.keys}
 * by {@link types.Key.value}'s.
 *
 * @param that - reference to be compared
 * @param other - to be compared against
 * @returns `true` if the key values are are equal
 */
export declare function referenceKeyValuesEqual(that: AasTypes.Reference, other: AasTypes.Reference): boolean;
/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined appropriately for all data specifications whose content is given
 * as IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export declare function dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>): boolean;
/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined appropriately for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export declare function dataSpecificationIec61360sForReferenceHaveAppropriateDataType(embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>): boolean;
/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined appropriately for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export declare function dataSpecificationIec61360sForDocumentHaveAppropriateDataType(embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>): boolean;
/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export declare function dataSpecificationIec61360sHaveDataType(embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>): boolean;
/**
 * Check that {@link types.DataSpecificationIec61360.value}
 * is defined for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export declare function dataSpecificationIec61360sHaveValue(embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>): boolean;
/**
 * Check that {@link types.DataSpecificationIec61360.definition}
 * is defined for all data specifications whose content is given as
 * IEC 61360 at least in English.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export declare function dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>): boolean;
/**
 * Check that the `text` corresponds to a BCP47 code for english.
 */
export declare function isBcp47ForEnglish(text: string): boolean;
/**
 * Verify the constraints of `that`.
 *
 * @param that - instance to be verified
 * @param recurse - if set, continue the verification recursively
 * @returns a stream of verification errors
 */
export declare function verify(that: AasTypes.Class, recurse?: boolean): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyNonEmptyXmlSerializableString(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyDateTimeUtc(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyDuration(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyBlobType(that: Uint8Array): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyIdentifier(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyValueTypeIec61360(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyNameType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyVersionType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyRevisionType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyLabelType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyMessageTopicType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyBcp47LanguageTag(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyContentType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyPathType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyQualifierType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyValueDataType(that: string): IterableIterator<VerificationError>;
/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export declare function verifyIdShortType(that: string): IterableIterator<VerificationError>;
//# sourceMappingURL=verification.d.ts.map