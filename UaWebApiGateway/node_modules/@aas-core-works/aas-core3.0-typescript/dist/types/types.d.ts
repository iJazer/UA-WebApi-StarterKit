/**
 * Provide an implementation of the Asset Administration Shell (AAS) V3.0.
 *
 * @remarks
 * The presented version of the Metamodel is related to the work of
 * aas-core-works, which can be found here: https://github.com/aas-core-works.
 *
 * The presented content is neither related to the IDTA nor
 * Plattform Industrie 4.0 and does not represent an official publication.
 *
 * We diverge from the book in the following points.
 *
 * We did not implement the following constraints as they are too general and can not
 * be formalized as part of the core library, but affects external components such as
 * AAS registry or AAS server:
 *
 * * Constraint AASd-022
 *
 * We did not implement the following constraints since they depend on registry and
 * de-referencing of {@link Reference} objects:
 *
 * * Constraint AASd-006
 * * Constraint AASd-007
 * * Constraint AASc-3a-003
 *
 * Some constraints are not enforceable as they depend on the wider context
 * such as language understanding, so we could not formalize them:
 *
 * * Constraint AASd-012: This constraint requires that the texts inside
 *   `Multi_language_property` shall have the same meanings in the separate languages.
 *   This cannot be tested.
 * * Constraint AASd-116: In the book, Constraint AASd-116 imposes a
 *   case-insensitive equality against `globalAssetId`. This is culturally-dependent,
 *   and depends on the system settings. For example, the case-folding
 *   for the letters "i" and "I" is different in Turkish from English.
 *
 *   We implement the constraint as case-sensitive instead to allow for interoperability
 *   across different culture settings.
 *
 * Furthermore, we diverge from the book in the following points regarding
 * the enumerations. We have to implement subsets of enumerations as sets as common
 * programming languages do not support inheritance of enumerations. The relationship
 * between the properties and the sets is defined through invariants. This causes
 * the following divergences:
 *
 * * We decided therefore to remove the enumeration `DataTypeDefRDF`
 *   and keep only {@link DataTypeDefXsd} as enumeration. Otherwise, we would have
 *   to write redundant invariants all over the meta-model because `DataTypeDefRDF`
 *   is actually never used in any type definition.
 * * The enumeration {@link AasSubmodelElements} is used in two different contexts.
 *   One context is the definition of key types in a reference. Another context is
 *   the definition of element types in a {@link SubmodelElementList}.
 *
 *   To avoid confusion, we introduce two separate enumerations for the separate contexts.
 *   Firstly, a set of {@link KeyTypes}, {@link constants!AAS_SUBMODEL_ELEMENTS_AS_KEYS} to
 *   represent the first context (key type in a reference).
 *   Secondly, the enumeration {@link AasSubmodelElements} is kept as designator
 *   for {@link SubmodelElementList.typeValueListElement}.
 * * The specification introduces several types of `Lang_string_set`.
 *   These types differ between the allowed length of their text inside the singular
 *   `Lang_string` objects. Since the native representation of `Lang_string_set` as
 *   `List` of `Lang_string` is required by specification, it is impossible to
 *   introduce separate `Lang_string_set` types. Therefore, the distinction is drawn here
 *   between the `Lang_string` types.
 *
 *   `DefinitionTypeIEC61360` is represented as a
 *   `List` of {@link LangStringDefinitionTypeIec61360}
 *
 *   `MultiLanguageNameType` is represented as a
 *   `List` of {@link LangStringNameType}
 *
 *   `PreferredNameTypeIEC61360` is represented as a
 *   `List` of {@link LangStringPreferredNameTypeIec61360}
 *
 *   `ShortNameTypeIEC61360` is represented as a
 *   `List` of {@link LangStringShortNameTypeIec61360}
 *
 *   `MultiLanguageTextType` is represented as a
 *   `List` of {@link LangStringTextType}
 *
 *   Furthermore, since `Lang_string` is not used anywhere, we rename it to
 *   {@link IAbstractLangString}.
 *
 * Concerning the data specifications, we embed them within
 * {@link IHasDataSpecification} instead of referencing them *via* an external reference.
 * The working group decided to change the rules for serialization *after* the book was
 * published. The data specifications are critical in applications, but there is no
 * possibility to access them through a data channel as they are not part of
 * an environment.
 */
/**
 * Represent runtime model type of an instance.
 */
export declare enum ModelType {
    Extension = 0,
    AdministrativeInformation = 1,
    Qualifier = 2,
    AssetAdministrationShell = 3,
    AssetInformation = 4,
    Resource = 5,
    SpecificAssetId = 6,
    Submodel = 7,
    RelationshipElement = 8,
    SubmodelElementList = 9,
    SubmodelElementCollection = 10,
    Property = 11,
    MultiLanguageProperty = 12,
    Range = 13,
    ReferenceElement = 14,
    Blob = 15,
    File = 16,
    AnnotatedRelationshipElement = 17,
    Entity = 18,
    EventPayload = 19,
    BasicEventElement = 20,
    Operation = 21,
    OperationVariable = 22,
    Capability = 23,
    ConceptDescription = 24,
    Reference = 25,
    Key = 26,
    LangStringNameType = 27,
    LangStringTextType = 28,
    Environment = 29,
    EmbeddedDataSpecification = 30,
    LevelType = 31,
    ValueReferencePair = 32,
    ValueList = 33,
    LangStringPreferredNameTypeIec61360 = 34,
    LangStringShortNameTypeIec61360 = 35,
    LangStringDefinitionTypeIec61360 = 36,
    DataSpecificationIec61360 = 37
}
/**
 * Iterate over the literals of {@link ModelType}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overModelType(): Iterable<ModelType>;
/**
 * Represent the most general class of an AAS model.
 */
export declare abstract class Class {
    /**
     * Indicate the runtime model type of an instance.
     */
    abstract modelType(): ModelType;
    /**
     * Iterate over all the instances referenced from this one.
     */
    abstract descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over all the instances referenced from this one.
     */
    abstract descend(): IterableIterator<Class>;
    /**
     * Dispatch the `visitor` on this instance.
     *
     * @param visitor - to be dispatched
     */
    abstract accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch the `visitor` on this instance with `context`.
     *
     * @param visitor - to be dispatched
     * @param context - of the visitation
     * @typeParam ContextT - type of the visitation context
     */
    abstract acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to be dispatched
     * @return this instance transformed
     * @typeParam T - type of the transformation result
     */
    abstract transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to be dispatched
     * @param context - of the transformation
     * @return this instance transformed
     * @typeParam T - type of the transformation result
     */
    abstract transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
}
/**
 * Element that can have a semantic definition plus some supplemental semantic
 * definitions.
 *
 * Constraint `AASd-118`:
 * If there are ID {@link supplementalSemanticIds} defined
 * then there shall be also a main semantic ID {@link semanticId}.
 */
export interface IHasSemantics extends Class {
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
}
/**
 * Single extension of an element.
 */
export declare class Extension extends Class implements IHasSemantics {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Name of the extension.
     *
     * Constraint `AASd-077`:
     * The name of an extension (Extension/name) within {@link IHasExtensions} needs
     * to be unique.
     */
    name: string;
    /**
     * Type of the value of the extension.
     *
     * @remarks
     * Default: {@link DataTypeDefXsd.String}
     */
    valueType: DataTypeDefXsd | null;
    /**
     * Value of the extension
     */
    value: string | null;
    /**
     * Reference to an element the extension refers to.
     */
    refersTo: Array<Reference> | null;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link refersTo} if it is set, or yield nothing.
     */
    overRefersToOrEmpty(): IterableIterator<Reference>;
    /**
     * @returns {@link valueType} if set or the default value otherwise.
     */
    valueTypeOrDefault(): DataTypeDefXsd;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(name: string, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, valueType?: DataTypeDefXsd | null, value?: string | null, refersTo?: Array<Reference> | null);
}
/**
 * Element that can be extended by proprietary extensions.
 *
 * @remarks
 * **Note**:
 * Extensions are proprietary, i.e. they do not support global interoperability.
 */
export interface IHasExtensions extends Class {
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
}
/**
 * An element that is referable by its {@link idShort}.
 *
 * @remarks
 * This ID is not globally unique.
 * This ID is unique within the name space of the element.
 *
 * Constraint `AASd-022`:
 * {@link idShort} of non-identifiable referables
 * within the same name space shall be unique (case-sensitive).
 */
export interface IReferable extends IHasExtensions {
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
}
/**
 * An element that has a globally unique identifier.
 */
export interface IIdentifiable extends IReferable {
    /**
     * Administrative information of an identifiable element.
     *
     * @remarks
     * **Note**:
     * Some of the administrative information like the version number might need to
     * be part of the identification.
     */
    administration: AdministrativeInformation | null;
    /**
     * The globally unique identification of the element.
     */
    id: string;
}
/**
 * Enumeration for denoting whether an element is a template or an instance.
 */
export declare enum ModellingKind {
    /**
     * Specification of the common features of a structured element in sufficient detail
     * that such a instance can be instantiated using it
     */
    Template = 0,
    /**
     * Concrete, clearly identifiable element instance. Its creation and validation
     * may be guided by a corresponding element template.
     */
    Instance = 1
}
/**
 * Iterate over the literals of {@link ModellingKind}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overModellingKind(): IterableIterator<ModellingKind>;
/**
 * An element with a kind is an element that can either represent a template or an
 * instance.
 *
 * @remarks
 * Default for an element is that it is representing an instance.
 */
export interface IHasKind extends Class {
    /**
     * Kind of the element: either type or instance.
     *
     * @remarks
     * Default: {@link ModellingKind.Instance}
     */
    kind: ModellingKind | null;
    kindOrDefault(): ModellingKind;
}
/**
 * Element that can be extended by using data specification templates.
 *
 * @remarks
 * A data specification template defines a named set of additional attributes an
 * element may or shall have. The data specifications used are explicitly specified
 * with their global ID.
 */
export interface IHasDataSpecification extends Class {
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
}
/**
 * Administrative meta-information for an element like version
 * information.
 *
 * Constraint `AASd-005`:
 * If {@link AdministrativeInformation.version} is not specified then also {@link AdministrativeInformation.revision} shall be
 * unspecified. This means, a revision requires a version. If there is no version
 * there is no revision neither. Revision is optional.
 */
export declare class AdministrativeInformation extends Class implements IHasDataSpecification {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Version of the element.
     */
    version: string | null;
    /**
     * Revision of the element.
     */
    revision: string | null;
    /**
     * The subject ID of the subject responsible for making the element.
     */
    creator: Reference | null;
    /**
     * Identifier of the template that guided the creation of the element.
     *
     * @remarks
     * **Note**:
     * In case of a submodel the {@link templateId} is the identifier
     * of the submodel template ID that guided the creation of the submodel
     *
     * **Note**:
     * The {@link templateId} is not relevant for validation in Submodels.
     * For validation the {@link Submodel.semanticId} shall be used.
     *
     * **Note**:
     * Usage of {@link templateId} is not restricted to submodel instances. So also
     * the creation of submodel templates can be guided by another submodel template.
     */
    templateId: string | null;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, version?: string | null, revision?: string | null, creator?: Reference | null, templateId?: string | null);
}
/**
 * The value of a qualifiable element may be further qualified by one or more
 * qualifiers.
 *
 * Constraint `AASd-119`:
 * If any {@link Qualifier.kind} value of {@link qualifiers} is
 * equal to {@link QualifierKind.TemplateQualifier} and the qualified element
 * inherits from {@link IHasKind} then the qualified element shall be of
 * kind Template ({@link IHasKind.kind} = {@link ModellingKind.Template}).
 *
 * **Note**:
 * This constraint is checked at {@link Submodel}.
 */
export interface IQualifiable extends Class {
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
}
/**
 * Enumeration for kinds of qualifiers.
 *
 * @remarks
 * **Note**:
 * This element is experimental and therefore may be subject to change or may be
 * removed completely in future versions of the meta-model.
 */
export declare enum QualifierKind {
    /**
     * qualifies the value of the element and can change during run-time.
     *
     * @remarks
     *
     * Value qualifiers are only applicable to elements with kind
     * {@link ModellingKind.Instance}.
     */
    ValueQualifier = 0,
    /**
     * qualifies the semantic definition the element is referring to
     * ({@link IHasSemantics.semanticId})
     */
    ConceptQualifier = 1,
    /**
     * qualifies the elements within a specific submodel on concept level.
     *
     * @remarks
     *
     * Template qualifiers are only applicable to elements with kind
     * {@link ModellingKind.Template}.
     */
    TemplateQualifier = 2
}
/**
 * Iterate over the literals of {@link QualifierKind}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overQualifierKind(): IterableIterator<QualifierKind>;
/**
 * A qualifier is a type-value-pair that makes additional statements w.r.t. the value
 * of the element.
 *
 * Constraint `AASd-006`:
 * If both the {@link Qualifier.value} and the {@link Qualifier.valueId} of
 * a {@link Qualifier} are present then the {@link Qualifier.value} needs
 * to be identical to the value of the referenced coded value
 * in {@link Qualifier.valueId}.
 *
 * Constraint `AASd-020`:
 * The value of {@link Qualifier.value} shall be consistent to the data type as
 * defined in {@link Qualifier.valueType}.
 */
export declare class Qualifier extends Class implements IHasSemantics {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * The qualifier kind describes the kind of the qualifier that is applied to the
     * element.
     *
     * @remarks
     * Default: {@link QualifierKind.ConceptQualifier}
     */
    kind: QualifierKind | null;
    /**
     * The qualifier *type* describes the type of the qualifier that is applied to
     * the element.
     */
    type: string;
    /**
     * Data type of the qualifier value.
     */
    valueType: DataTypeDefXsd;
    /**
     * The qualifier value is the value of the qualifier.
     */
    value: string | null;
    /**
     * Reference to the global unique ID of a coded value.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    valueId: Reference | null;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * @returns {@link kind} if set or the default value otherwise.
     */
    kindOrDefault(): QualifierKind;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(type: string, valueType: DataTypeDefXsd, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, kind?: QualifierKind | null, value?: string | null, valueId?: Reference | null);
}
/**
 * An asset administration shell.
 */
export declare class AssetAdministrationShell extends Class implements IIdentifiable, IHasDataSpecification {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Administrative information of an identifiable element.
     *
     * @remarks
     * **Note**:
     * Some of the administrative information like the version number might need to
     * be part of the identification.
     */
    administration: AdministrativeInformation | null;
    /**
     * The globally unique identification of the element.
     */
    id: string;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * The reference to the AAS the AAS was derived from.
     */
    derivedFrom: Reference | null;
    /**
     * Meta-information about the asset the AAS is representing.
     */
    assetInformation: AssetInformation;
    /**
     * References to submodels of the AAS.
     *
     * @remarks
     * A submodel is a description of an aspect of the asset the AAS is representing.
     *
     * The asset of an AAS is typically described by one or more submodels.
     *
     * Temporarily no submodel might be assigned to the AAS.
     */
    submodels: Array<Reference> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link submodels} if it is set, or yield nothing.
     */
    overSubmodelsOrEmpty(): IterableIterator<Reference>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(id: string, assetInformation: AssetInformation, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, administration?: AdministrativeInformation | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, derivedFrom?: Reference | null, submodels?: Array<Reference> | null);
}
/**
 * In {@link AssetInformation} identifying meta data of the asset that is
 * represented by an AAS is defined.
 *
 * @remarks
 * The asset may either represent an asset type or an asset instance.
 *
 * The asset has a globally unique identifier plus – if needed – additional domain
 * specific (proprietary) identifiers. However, to support the corner case of very
 * first phase of lifecycle where a stabilised/constant_set global asset identifier
 * does not already exist, the corresponding attribute {@link AssetInformation.globalAssetId} is
 * optional.
 *
 * Constraint `AASd-116`:
 * `globalAssetId` is a reserved key. If used as value for
 * {@link SpecificAssetId.name} then {@link SpecificAssetId.value} shall be
 * identical to {@link AssetInformation.globalAssetId}.
 *
 * **Note**:
 * Constraint AASd-116 is important to enable a generic search across
 * global and specific asset IDs.
 *
 * **Note**:
 * In the book, Constraint AASd-116 imposes a
 * case-insensitive equality against `globalAssetId`. This is
 * culturally-dependent, and depends on the system settings.
 * For example, the case-folding for the letters "i" and "I" is
 * different in Turkish from English.
 *
 * We implement the constraint as case-sensitive instead to allow
 * for interoperability across different culture settings.
 *
 * Constraint `AASd-131`:
 * For {@link AssetInformation} either the {@link AssetInformation.globalAssetId} shall be
 * defined or at least one item in {@link AssetInformation.specificAssetIds}.
 */
export declare class AssetInformation extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Denotes whether the Asset is of kind {@link AssetKind.Type} or
     * {@link AssetKind.Instance}.
     */
    assetKind: AssetKind;
    /**
     * Global identifier of the asset the AAS is representing.
     *
     * @remarks
     * This attribute is required as soon as the AAS is exchanged via partners in the life
     * cycle of the asset. In a first phase of the life cycle the asset might not yet have
     * a global ID but already an internal identifier. The internal identifier would be
     * modelled via {@link specificAssetIds}.
     *
     * **Note**:
     * This is a global reference.
     */
    globalAssetId: string | null;
    /**
     * Additional domain-specific, typically proprietary identifier for the asset like
     * e.g., serial number etc.
     */
    specificAssetIds: Array<SpecificAssetId> | null;
    /**
     * In case {@link assetKind} is applicable the {@link assetType} is the asset ID
     * of the type asset of the asset under consideration
     * as identified by {@link globalAssetId}.
     *
     * @remarks
     * **Note**:
     * In case {@link assetKind} is "Instance" than the {@link assetType} denotes
     * which "Type" the asset is of. But it is also possible
     * to have an {@link assetType} of an asset of kind "Type".
     */
    assetType: string | null;
    /**
     * Thumbnail of the asset represented by the Asset Administration Shell.
     *
     * @remarks
     * Used as default.
     */
    defaultThumbnail: Resource | null;
    /**
     * Yield from {@link specificAssetIds} if it is set, or yield nothing.
     */
    overSpecificAssetIdsOrEmpty(): IterableIterator<SpecificAssetId>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(assetKind: AssetKind, globalAssetId?: string | null, specificAssetIds?: Array<SpecificAssetId> | null, assetType?: string | null, defaultThumbnail?: Resource | null);
}
/**
 * Resource represents an address to a file (a locator). The value is an URI that
 * can represent an absolute or relative path
 */
export declare class Resource extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Path and name of the resource (with file extension).
     *
     * @remarks
     * The path can be absolute or relative.
     */
    path: string;
    /**
     * Content type of the content of the file.
     *
     * @remarks
     * The content type states which file extensions the file can have.
     */
    contentType: string | null;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(path: string, contentType?: string | null);
}
/**
 * Enumeration for denoting whether an asset is a type asset or an instance asset.
 */
export declare enum AssetKind {
    /**
     * Type asset
     */
    Type = 0,
    /**
     * Instance asset
     */
    Instance = 1,
    /**
     * Neither a type asset nor an instance asset
     */
    NotApplicable = 2
}
/**
 * Iterate over the literals of {@link AssetKind}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overAssetKind(): IterableIterator<AssetKind>;
/**
 * A specific asset ID describes a generic supplementary identifying attribute of the
 * asset.
 *
 * @remarks
 * The specific asset ID is not necessarily globally unique.
 *
 * Constraint `AASd-133`:
 * {@link SpecificAssetId.externalSubjectId} shall be an external reference,
 * i.e. {@link Reference.type} = {@link ReferenceTypes.ExternalReference}.
 */
export declare class SpecificAssetId extends Class implements IHasSemantics {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Name of the identifier
     */
    name: string;
    /**
     * The value of the specific asset identifier with the corresponding name.
     */
    value: string;
    /**
     * The (external) subject the key belongs to or has meaning to.
     *
     * @remarks
     * **Note**:
     * This is a global reference.
     */
    externalSubjectId: Reference | null;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(name: string, value: string, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, externalSubjectId?: Reference | null);
}
/**
 * A submodel defines a specific aspect of the asset represented by the AAS.
 *
 * @remarks
 * A submodel is used to structure the digital representation and technical
 * functionality of an Administration Shell into distinguishable parts. Each submodel
 * refers to a well-defined domain or subject matter. Submodels can become
 * standardized and, thus, become submodels templates.
 */
export declare class Submodel extends Class implements IIdentifiable, IHasKind, IHasSemantics, IQualifiable, IHasDataSpecification {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Administrative information of an identifiable element.
     *
     * @remarks
     * **Note**:
     * Some of the administrative information like the version number might need to
     * be part of the identification.
     */
    administration: AdministrativeInformation | null;
    /**
     * The globally unique identification of the element.
     */
    id: string;
    /**
     * Kind of the element: either type or instance.
     *
     * @remarks
     * Default: {@link ModellingKind.Instance}
     */
    kind: ModellingKind | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * A submodel consists of zero or more submodel elements.
     */
    submodelElements: Array<ISubmodelElement> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link submodelElements} if it is set, or yield nothing.
     */
    overSubmodelElementsOrEmpty(): IterableIterator<ISubmodelElement>;
    /**
     * @returns {@link kind} if set or the default value otherwise.
     */
    kindOrDefault(): ModellingKind;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(id: string, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, administration?: AdministrativeInformation | null, kind?: ModellingKind | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, submodelElements?: Array<ISubmodelElement> | null);
}
/**
 * A submodel element is an element suitable for the description and differentiation of
 * assets.
 *
 * @remarks
 * It is recommended to add a {@link IHasSemantics.semanticId} to a submodel element.
 *
 * Constraint `AASd-129`:
 * If any {@link Qualifier.kind} value of {@link qualifiers} (attribute qualifier
 * inherited via Qualifiable) is equal to {@link QualifierKind.TemplateQualifier}
 * then the submodel element shall be part of a submodel template, i.e.
 * a Submodel with {@link Submodel.kind} (attribute kind inherited via
 * {@link IHasKind}) value is equal to {@link ModellingKind.Template}.
 */
export interface ISubmodelElement extends IReferable, IHasSemantics, IQualifiable, IHasDataSpecification {
}
/**
 * A relationship element is used to define a relationship between two elements
 * being either referable (model reference) or external (global reference).
 */
export interface IRelationshipElement extends ISubmodelElement {
    /**
     * Reference to the first element in the relationship taking the role of the subject.
     */
    first: Reference;
    /**
     * Reference to the second element in the relationship taking the role of the object.
     */
    second: Reference;
}
/**
 * A relationship element is used to define a relationship between two elements
 * being either referable (model reference) or external (global reference).
 */
export declare class RelationshipElement extends Class implements IRelationshipElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Reference to the first element in the relationship taking the role of the subject.
     */
    first: Reference;
    /**
     * Reference to the second element in the relationship taking the role of the object.
     */
    second: Reference;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(first: Reference, second: Reference, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null);
}
/**
 * Enumeration of all possible elements of a {@link SubmodelElementList}.
 */
export declare enum AasSubmodelElements {
    AnnotatedRelationshipElement = 0,
    BasicEventElement = 1,
    Blob = 2,
    Capability = 3,
    DataElement = 4,
    Entity = 5,
    EventElement = 6,
    File = 7,
    MultiLanguageProperty = 8,
    Operation = 9,
    Property = 10,
    Range = 11,
    ReferenceElement = 12,
    RelationshipElement = 13,
    SubmodelElement = 14,
    SubmodelElementList = 15,
    SubmodelElementCollection = 16
}
/**
 * Iterate over the literals of {@link AasSubmodelElements}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overAasSubmodelElements(): IterableIterator<AasSubmodelElements>;
/**
 * A submodel element list is an ordered list of submodel elements.
 *
 * @remarks
 * The numbering starts with zero (0).
 *
 * Constraint `AASd-107`:
 * If a first level child element in a {@link SubmodelElementList} has
 * a {@link IHasSemantics.semanticId} it
 * shall be identical to {@link SubmodelElementList.semanticIdListElement}.
 *
 * Constraint `AASd-114`:
 * If two first level child elements in a {@link SubmodelElementList} have
 * a {@link IHasSemantics.semanticId} then they shall be identical.
 *
 * Constraint `AASd-115`:
 * If a first level child element in a {@link SubmodelElementList} does not
 * specify a {@link IHasSemantics.semanticId} then the value is assumed to be
 * identical to {@link SubmodelElementList.semanticIdListElement}.
 *
 * Constraint `AASd-120`:
 * The {@link SubmodelElementList.idShort} of a {@link ISubmodelElement} being a direct child of a
 * {@link SubmodelElementList} shall not be specified.
 *
 * Constraint `AASd-108`:
 * All first level child elements in a {@link SubmodelElementList} shall have
 * the same submodel element type as specified in {@link SubmodelElementList.typeValueListElement}.
 *
 * Constraint `AASd-109`:
 * If {@link SubmodelElementList.typeValueListElement} is equal to
 * {@link AasSubmodelElements.Property} or
 * {@link AasSubmodelElements.Range}
 * {@link SubmodelElementList.valueTypeListElement} shall be set and all first
 * level child elements in the {@link SubmodelElementList} shall have
 * the value type as specified in {@link SubmodelElementList.valueTypeListElement}.
 */
export declare class SubmodelElementList extends Class implements ISubmodelElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Defines whether order in list is relevant. If {@link orderRelevant} = `False`
     * then the list is representing a set or a bag.
     *
     * @remarks
     * Default: `True`
     */
    orderRelevant: boolean | null;
    /**
     * Semantic ID the submodel elements contained in the list match to.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticIdListElement: Reference | null;
    /**
     * The submodel element type of the submodel elements contained in the list.
     */
    typeValueListElement: AasSubmodelElements;
    /**
     * The value type of the submodel element contained in the list.
     */
    valueTypeListElement: DataTypeDefXsd | null;
    /**
     * Submodel element contained in the list.
     *
     * @remarks
     * The list is ordered.
     */
    value: Array<ISubmodelElement> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link value} if it is set, or yield nothing.
     */
    overValueOrEmpty(): IterableIterator<ISubmodelElement>;
    /**
     * @returns {@link orderRelevant} if set or the default value otherwise.
     */
    orderRelevantOrDefault(): boolean;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(typeValueListElement: AasSubmodelElements, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, orderRelevant?: boolean | null, semanticIdListElement?: Reference | null, valueTypeListElement?: DataTypeDefXsd | null, value?: Array<ISubmodelElement> | null);
}
/**
 * A submodel element collection is a kind of struct, i.e. a a logical encapsulation
 * of multiple named values. It has a fixed number of submodel elements.
 */
export declare class SubmodelElementCollection extends Class implements ISubmodelElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Submodel element contained in the collection.
     */
    value: Array<ISubmodelElement> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link value} if it is set, or yield nothing.
     */
    overValueOrEmpty(): IterableIterator<ISubmodelElement>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, value?: Array<ISubmodelElement> | null);
}
/**
 * A data element is a submodel element that is not further composed out of
 * other submodel elements.
 *
 * @remarks
 * A data element is a submodel element that has a value. The type of value differs
 * for different subtypes of data elements.
 *
 * Constraint `AASd-090`:
 * For data elements {@link category} shall be one of the following
 * values: `CONSTANT`, `PARAMETER` or `VARIABLE`.
 *
 * Default: `VARIABLE`
 */
export interface IDataElement extends ISubmodelElement {
    categoryOrDefault(): string;
}
/**
 * A property is a data element that has a single value.
 *
 * Constraint `AASd-007`:
 * If both, the {@link Property.value} and the {@link Property.valueId} are
 * present then the value of {@link Property.value} needs to be identical to
 * the value of the referenced coded value in {@link Property.valueId}.
 */
export declare class Property extends Class implements IDataElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Data type of the value
     */
    valueType: DataTypeDefXsd;
    /**
     * The value of the property instance.
     */
    value: string | null;
    /**
     * Reference to the global unique ID of a coded value.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    valueId: Reference | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * @returns {@link category} if set or the default value otherwise.
     */
    categoryOrDefault(): string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(valueType: DataTypeDefXsd, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, value?: string | null, valueId?: Reference | null);
}
/**
 * A property is a data element that has a multi-language value.
 *
 * Constraint `AASd-012`:
 * If both the {@link MultiLanguageProperty.value} and the {@link MultiLanguageProperty.valueId} are present then for each
 * string in a specific language the meaning must be the same as specified in
 * {@link MultiLanguageProperty.valueId}.
 */
export declare class MultiLanguageProperty extends Class implements IDataElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * The value of the property instance.
     */
    value: Array<LangStringTextType> | null;
    /**
     * Reference to the global unique ID of a coded value.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    valueId: Reference | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link value} if it is set, or yield nothing.
     */
    overValueOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * @returns {@link category} if set or the default value otherwise.
     */
    categoryOrDefault(): string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, value?: Array<LangStringTextType> | null, valueId?: Reference | null);
}
/**
 * A range data element is a data element that defines a range with min and max.
 */
export declare class Range extends Class implements IDataElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Data type of the min und max
     */
    valueType: DataTypeDefXsd;
    /**
     * The minimum value of the range.
     *
     * @remarks
     * If the min value is missing, then the value is assumed to be negative infinite.
     */
    min: string | null;
    /**
     * The maximum value of the range.
     *
     * @remarks
     * If the max value is missing, then the value is assumed to be positive infinite.
     */
    max: string | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * @returns {@link category} if set or the default value otherwise.
     */
    categoryOrDefault(): string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(valueType: DataTypeDefXsd, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, min?: string | null, max?: string | null);
}
/**
 * A reference element is a data element that defines a logical reference to another
 * element within the same or another AAS or a reference to an external object or
 * entity.
 */
export declare class ReferenceElement extends Class implements IDataElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Global reference to an external object or entity or a logical reference to
     * another element within the same or another AAS (i.e. a model reference to
     * a Referable).
     */
    value: Reference | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * @returns {@link category} if set or the default value otherwise.
     */
    categoryOrDefault(): string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, value?: Reference | null);
}
/**
 * A {@link Blob} is a data element that represents a file that is contained with its
 * source code in the value attribute.
 */
export declare class Blob extends Class implements IDataElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * The value of the {@link Blob} instance of a blob data element.
     *
     * @remarks
     * **Note**:
     * In contrast to the file property the file content is stored directly as value
     * in the {@link Blob} data element.
     */
    value: Uint8Array | null;
    /**
     * Content type of the content of the {@link Blob}.
     *
     * @remarks
     * The content type (MIME type) states which file extensions the file can have.
     *
     * Valid values are content types like e.g. `application/json`, `application/xls`,
     * `image/jpg`.
     *
     * The allowed values are defined as in RFC2046.
     */
    contentType: string;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * @returns {@link category} if set or the default value otherwise.
     */
    categoryOrDefault(): string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(contentType: string, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, value?: Uint8Array | null);
}
/**
 * A File is a data element that represents an address to a file (a locator).
 *
 * @remarks
 * The value is an URI that can represent an absolute or relative path.
 */
export declare class File extends Class implements IDataElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Path and name of the referenced file (with file extension).
     *
     * @remarks
     * The path can be absolute or relative.
     */
    value: string | null;
    /**
     * Content type of the content of the file.
     *
     * @remarks
     * The content type states which file extensions the file can have.
     */
    contentType: string;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * @returns {@link category} if set or the default value otherwise.
     */
    categoryOrDefault(): string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(contentType: string, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, value?: string | null);
}
/**
 * An annotated relationship element is a relationship element that can be annotated
 * with additional data elements.
 */
export declare class AnnotatedRelationshipElement extends Class implements IRelationshipElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Reference to the first element in the relationship taking the role of the subject.
     */
    first: Reference;
    /**
     * Reference to the second element in the relationship taking the role of the object.
     */
    second: Reference;
    /**
     * A data element that represents an annotation that holds for the relationship
     * between the two elements
     */
    annotations: Array<IDataElement> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link annotations} if it is set, or yield nothing.
     */
    overAnnotationsOrEmpty(): IterableIterator<IDataElement>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(first: Reference, second: Reference, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, annotations?: Array<IDataElement> | null);
}
/**
 * An entity is a submodel element that is used to model entities.
 *
 * Constraint `AASd-014`:
 * Either the attribute {@link Entity.globalAssetId} or {@link Entity.specificAssetIds}
 * of an {@link Entity} must be set if {@link Entity.entityType} is set to
 * {@link EntityType.SelfManagedEntity}. They are not existing otherwise.
 */
export declare class Entity extends Class implements ISubmodelElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Describes statements applicable to the entity by a set of submodel elements,
     * typically with a qualified value.
     */
    statements: Array<ISubmodelElement> | null;
    /**
     * Describes whether the entity is a co-managed entity or a self-managed entity.
     */
    entityType: EntityType;
    /**
     * Global identifier of the asset the entity is representing.
     *
     * @remarks
     * **Note**:
     * This is a global reference.
     */
    globalAssetId: string | null;
    /**
     * Reference to a specific asset ID representing a supplementary identifier
     * of the asset represented by the Asset Administration Shell.
     */
    specificAssetIds: Array<SpecificAssetId> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link statements} if it is set, or yield nothing.
     */
    overStatementsOrEmpty(): IterableIterator<ISubmodelElement>;
    /**
     * Yield from {@link specificAssetIds} if it is set, or yield nothing.
     */
    overSpecificAssetIdsOrEmpty(): IterableIterator<SpecificAssetId>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(entityType: EntityType, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, statements?: Array<ISubmodelElement> | null, globalAssetId?: string | null, specificAssetIds?: Array<SpecificAssetId> | null);
}
/**
 * Enumeration for denoting whether an entity is a self-managed entity or a co-managed
 * entity.
 */
export declare enum EntityType {
    /**
     * For co-managed entities there is no separate AAS. Co-managed entities need to be
     * part of a self-managed entity.
     */
    CoManagedEntity = 0,
    /**
     * Self-Managed Entities have their own AAS but can be part of the bill of material of
     * a composite self-managed entity.
     *
     * @remarks
     *
     * The asset of an I4.0 Component is a self-managed entity per definition.
     */
    SelfManagedEntity = 1
}
/**
 * Iterate over the literals of {@link EntityType}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overEntityType(): IterableIterator<EntityType>;
/**
 * Direction
 *
 * @remarks
 * **Note**:
 * This element is experimental and therefore may be subject to change or may be
 * removed completely in future versions of the meta-model.
 */
export declare enum Direction {
    /**
     * Input direction.
     */
    Input = 0,
    /**
     * Output direction
     */
    Output = 1
}
/**
 * Iterate over the literals of {@link Direction}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overDirection(): IterableIterator<Direction>;
/**
 * State of an event
 *
 * @remarks
 * **Note**:
 * This element is experimental and therefore may be subject to change or may be
 * removed completely in future versions of the meta-model.
 */
export declare enum StateOfEvent {
    /**
     * Event is on
     */
    On = 0,
    /**
     * Event is off.
     */
    Off = 1
}
/**
 * Iterate over the literals of {@link StateOfEvent}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overStateOfEvent(): IterableIterator<StateOfEvent>;
/**
 * Defines the necessary information of an event instance sent out or received.
 *
 * @remarks
 * **Note**:
 * This element is experimental and therefore may be subject to change or may be
 * removed completely in future versions of the meta-model.
 */
export declare class EventPayload extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Reference to the source event element, including identification of
     * {@link AssetAdministrationShell}, {@link Submodel},
     * {@link ISubmodelElement}'s.
     */
    source: Reference;
    /**
     * {@link IHasSemantics.semanticId} of the source event element, if available
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    sourceSemanticId: Reference | null;
    /**
     * Reference to the referable, which defines the scope of the event.
     *
     * @remarks
     * Can be {@link AssetAdministrationShell}, {@link Submodel} or
     * {@link ISubmodelElement}.
     */
    observableReference: Reference;
    /**
     * {@link IHasSemantics.semanticId} of the referable which defines the scope of
     * the event, if available.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    observableSemanticId: Reference | null;
    /**
     * Information for the outer message infrastructure for scheduling the event to
     * the respective communication channel.
     */
    topic: string | null;
    /**
     * Subject, who/which initiated the creation.
     *
     * @remarks
     * **Note**:
     * This is an external reference.
     */
    subjectId: Reference | null;
    /**
     * Timestamp in UTC, when this event was triggered.
     */
    timeStamp: string;
    /**
     * Event specific payload.
     */
    payload: Uint8Array | null;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(source: Reference, observableReference: Reference, timeStamp: string, sourceSemanticId?: Reference | null, observableSemanticId?: Reference | null, topic?: string | null, subjectId?: Reference | null, payload?: Uint8Array | null);
}
/**
 * An event element.
 *
 * @remarks
 * **Note**:
 * This element is experimental and therefore may be subject to change or may be
 * removed completely in future versions of the meta-model.
 */
export interface IEventElement extends ISubmodelElement {
}
/**
 * A basic event element.
 *
 * @remarks
 * **Note**:
 * This element is experimental and therefore may be subject to change or may be
 * removed completely in future versions of the meta-model.
 */
export declare class BasicEventElement extends Class implements IEventElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Reference to the {@link IReferable}, which defines the scope of the event.
     * Can be {@link AssetAdministrationShell}, {@link Submodel}, or
     * {@link ISubmodelElement}.
     *
     * @remarks
     * Reference to a referable, e.g., a data element or
     * a submodel, that is being observed.
     */
    observed: Reference;
    /**
     * Direction of event.
     *
     * @remarks
     * Can be `{ Input, Output }`.
     */
    direction: Direction;
    /**
     * State of event.
     *
     * @remarks
     * Can be `{ On, Off }`.
     */
    state: StateOfEvent;
    /**
     * Information for the outer message infrastructure for scheduling the event to the
     * respective communication channel.
     */
    messageTopic: string | null;
    /**
     * Information, which outer message infrastructure shall handle messages for
     * the {@link IEventElement}. Refers to a {@link Submodel},
     * {@link SubmodelElementList}, {@link SubmodelElementCollection} or
     * {@link Entity}, which contains {@link IDataElement}'s describing
     * the proprietary specification for the message broker.
     *
     * @remarks
     * **Note**:
     * For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
     * proprietary specification could be standardized by having respective Submodels.
     */
    messageBroker: Reference | null;
    /**
     * Timestamp in UTC, when the last event was received (input direction) or sent
     * (output direction).
     */
    lastUpdate: string | null;
    /**
     * For input direction, reports on the maximum frequency, the software entity behind
     * the respective Referable can handle input events.
     *
     * @remarks
     * For output events, specifies the maximum frequency of outputting this event to
     * an outer infrastructure.
     *
     * Might be not specified, that is, there is no minimum interval.
     */
    minInterval: string | null;
    /**
     * For input direction: not applicable.
     *
     * @remarks
     * For output direction: maximum interval in time, the respective Referable shall send
     * an update of the status of the event, even if no other trigger condition for
     * the event was not met.
     *
     * Might be not specified, that is, there is no maximum interval
     */
    maxInterval: string | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(observed: Reference, direction: Direction, state: StateOfEvent, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, messageTopic?: string | null, messageBroker?: Reference | null, lastUpdate?: string | null, minInterval?: string | null, maxInterval?: string | null);
}
/**
 * An operation is a submodel element with input and output variables.
 *
 * Constraint `AASd-134`:
 * For an {@link Operation} the {@link IReferable.idShort} of all
 * {@link OperationVariable.value}'s in
 * {@link Operation.inputVariables}, {@link Operation.outputVariables}
 * and {@link Operation.inoutputVariables} shall be unique.
 */
export declare class Operation extends Class implements ISubmodelElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Input parameter of the operation.
     */
    inputVariables: Array<OperationVariable> | null;
    /**
     * Output parameter of the operation.
     */
    outputVariables: Array<OperationVariable> | null;
    /**
     * Parameter that is input and output of the operation.
     */
    inoutputVariables: Array<OperationVariable> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link inputVariables} if it is set, or yield nothing.
     */
    overInputVariablesOrEmpty(): IterableIterator<OperationVariable>;
    /**
     * Yield from {@link outputVariables} if it is set, or yield nothing.
     */
    overOutputVariablesOrEmpty(): IterableIterator<OperationVariable>;
    /**
     * Yield from {@link inoutputVariables} if it is set, or yield nothing.
     */
    overInoutputVariablesOrEmpty(): IterableIterator<OperationVariable>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, inputVariables?: Array<OperationVariable> | null, outputVariables?: Array<OperationVariable> | null, inoutputVariables?: Array<OperationVariable> | null);
}
/**
 * The value of an operation variable is a submodel element that is used as input
 * and/or output variable of an operation.
 */
export declare class OperationVariable extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Describes an argument or result of an operation via a submodel element
     */
    value: ISubmodelElement;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(value: ISubmodelElement);
}
/**
 * A capability is the implementation-independent description of the potential of an
 * asset to achieve a certain effect in the physical or virtual world.
 *
 * @remarks
 * **Note**:
 * The {@link Capability.semanticId} of a capability is typically an ontology.
 * Thus, reasoning on capabilities is enabled.
 */
export declare class Capability extends Class implements ISubmodelElement {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Identifier of the semantic definition of the element. It is called semantic ID
     * of the element or also main semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    semanticId: Reference | null;
    /**
     * Identifier of a supplemental semantic definition of the element.
     * It is called supplemental semantic ID of the element.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    supplementalSemanticIds: Array<Reference> | null;
    /**
     * Additional qualification of a qualifiable element.
     *
     * Constraint `AASd-021`:
     * Every qualifiable can only have one qualifier with the same
     * {@link Qualifier.type}.
     */
    qualifiers: Array<Qualifier> | null;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link supplementalSemanticIds} if it is set, or yield nothing.
     */
    overSupplementalSemanticIdsOrEmpty(): IterableIterator<Reference>;
    /**
     * Yield from {@link qualifiers} if it is set, or yield nothing.
     */
    overQualifiersOrEmpty(): IterableIterator<Qualifier>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, semanticId?: Reference | null, supplementalSemanticIds?: Array<Reference> | null, qualifiers?: Array<Qualifier> | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null);
}
/**
 * The semantics of a property or other elements that may have a semantic description
 * is defined by a concept description.
 *
 * @remarks
 * The description of the concept should follow a standardized schema (realized as
 * data specification template).
 *
 * Constraint `AASc-3a-004`:
 * For a {@link ConceptDescription} with {@link ConceptDescription.category} `PROPERTY` or
 * `VALUE` using data specification IEC61360,
 * the {@link DataSpecificationIec61360.dataType} is mandatory and shall be
 * one of: `DATE`, `STRING`, `STRING_TRANSLATABLE`, `INTEGER_MEASURE`,
 * `INTEGER_COUNT`, `INTEGER_CURRENCY`, `REAL_MEASURE`, `REAL_COUNT`,
 * `REAL_CURRENCY`, `BOOLEAN`, `RATIONAL`, `RATIONAL_MEASURE`,
 * `TIME`, `TIMESTAMP`.
 *
 * **Note**:
 * Note: categories are deprecated since V3.0 of Part 1a of the document series
 * "Details of the Asset Administration Shell".
 *
 * Constraint `AASc-3a-005`:
 * For a {@link ConceptDescription} with {@link ConceptDescription.category} `REFERENCE`
 * using data specification template IEC61360,
 * the {@link DataSpecificationIec61360.dataType} shall be
 * one of: `STRING`, `IRI`, `IRDI`.
 *
 * **Note**:
 * Note: categories are deprecated since V3.0 of Part 1a of the document series
 * "Details of the Asset Administration Shell".
 *
 * Constraint `AASc-3a-006`:
 * For a {@link ConceptDescription} with {@link ConceptDescription.category} `DOCUMENT`
 * using data specification IEC61360,
 * the {@link DataSpecificationIec61360.dataType} shall be one of `FILE`,
 * `BLOB`, `HTML`
 *
 * **Note**:
 * Categories are deprecated since V3.0 of Part 1a of the document series
 * "Details of the Asset Administration Shell".
 *
 * Constraint `AASc-3a-007`:
 * For a {@link ConceptDescription} with {@link ConceptDescription.category} `QUALIFIER_TYPE`
 * using data specification IEC61360,
 * the {@link DataSpecificationIec61360.dataType} is mandatory and shall be
 * defined.
 *
 * **Note**:
 * Categories are deprecated since V3.0 of Part 1a of the document series
 * "Details of the Asset Administration Shell".
 *
 * Constraint `AASc-3a-008`:
 * For a {@link ConceptDescription} using data specification template IEC61360,
 * {@link DataSpecificationIec61360.definition} is mandatory and shall be
 * defined at least in English.
 *
 * Exception: The concept description describes a value, i.e.
 * {@link DataSpecificationIec61360.value} is defined.
 *
 * Constraint `AASc-3a-003`:
 * For a {@link ConceptDescription} using data specification template IEC61360,
 * referenced via {@link DataSpecificationIec61360.valueList}
 * {@link ValueReferencePair.valueId}
 * the {@link DataSpecificationIec61360.value} shall be set.
 */
export declare class ConceptDescription extends Class implements IIdentifiable, IHasDataSpecification {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * An extension of the element.
     */
    extensions: Array<Extension> | null;
    /**
     * The category is a value that gives further meta information
     * w.r.t. to the class of the element.
     * It affects the expected existence of attributes and the applicability of
     * constraints.
     *
     * @remarks
     * **Note**:
     * The category is not identical to the semantic definition
     * ({@link IHasSemantics}) of an element. The category e.g. could denote that
     * the element is a measurement value whereas the semantic definition of
     * the element would denote that it is the measured temperature.
     */
    category: string | null;
    /**
     * In case of identifiables this attribute is a short name of the element.
     * In case of referable this ID is an identifying string of the element within
     * its name space.
     *
     * @remarks
     * **Note**:
     * In case the element is a property and the property has a semantic definition
     * ({@link IHasSemantics.semanticId}) conformant to IEC61360
     * the {@link IReferable.idShort} is typically identical to the short name in English.
     */
    idShort: string | null;
    /**
     * Display name. Can be provided in several languages.
     */
    displayName: Array<LangStringNameType> | null;
    /**
     * Description or comments on the element.
     *
     * @remarks
     * The description can be provided in several languages.
     *
     * If no description is defined, then the definition of the concept
     * description that defines the semantics of the element is used.
     *
     * Additional information can be provided, e.g., if the element is
     * qualified and which qualifier types can be expected in which
     * context or which additional data specification templates are
     * provided.
     */
    description: Array<LangStringTextType> | null;
    /**
     * Administrative information of an identifiable element.
     *
     * @remarks
     * **Note**:
     * Some of the administrative information like the version number might need to
     * be part of the identification.
     */
    administration: AdministrativeInformation | null;
    /**
     * The globally unique identification of the element.
     */
    id: string;
    /**
     * Embedded data specification.
     */
    embeddedDataSpecifications: Array<EmbeddedDataSpecification> | null;
    /**
     * Reference to an external definition the concept is compatible to or was derived
     * from.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     *
     * **Note**:
     * Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360
     */
    isCaseOf: Array<Reference> | null;
    /**
     * Yield from {@link extensions} if it is set, or yield nothing.
     */
    overExtensionsOrEmpty(): IterableIterator<Extension>;
    /**
     * Yield from {@link displayName} if it is set, or yield nothing.
     */
    overDisplayNameOrEmpty(): IterableIterator<LangStringNameType>;
    /**
     * Yield from {@link description} if it is set, or yield nothing.
     */
    overDescriptionOrEmpty(): IterableIterator<LangStringTextType>;
    /**
     * Yield from {@link embeddedDataSpecifications} if it is set, or yield nothing.
     */
    overEmbeddedDataSpecificationsOrEmpty(): IterableIterator<EmbeddedDataSpecification>;
    /**
     * Yield from {@link isCaseOf} if it is set, or yield nothing.
     */
    overIsCaseOfOrEmpty(): IterableIterator<Reference>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(id: string, extensions?: Array<Extension> | null, category?: string | null, idShort?: string | null, displayName?: Array<LangStringNameType> | null, description?: Array<LangStringTextType> | null, administration?: AdministrativeInformation | null, embeddedDataSpecifications?: Array<EmbeddedDataSpecification> | null, isCaseOf?: Array<Reference> | null);
}
/**
 * Reference types
 */
export declare enum ReferenceTypes {
    /**
     * External reference.
     */
    ExternalReference = 0,
    /**
     * Model reference.
     */
    ModelReference = 1
}
/**
 * Iterate over the literals of {@link ReferenceTypes}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overReferenceTypes(): IterableIterator<ReferenceTypes>;
/**
 * Reference to either a model element of the same or another AAS or to an external
 * entity.
 *
 * @remarks
 * A reference is an ordered list of keys.
 *
 * A model reference is an ordered list of keys, each key referencing an element. The
 * complete list of keys may for example be concatenated to a path that then gives
 * unique access to an element.
 *
 * An external reference is a reference to an external entity.
 *
 * Constraint `AASd-121`:
 * For {@link Reference}'s the value of {@link Key.type} of the first key of "
 * {@link Reference.keys} shall be one of {@link constants!GLOBALLY_IDENTIFIABLES}.
 *
 * Constraint `AASd-122`:
 * For external references, i.e. {@link Reference}'s with
 * {@link Reference.type} = {@link ReferenceTypes.ExternalReference}, the value
 * of {@link Key.type} of the first key of {@link Reference.keys} shall be one of
 * {@link constants!GENERIC_GLOBALLY_IDENTIFIABLES}.
 *
 * Constraint `AASd-123`:
 * For model references, i.e. {@link Reference}'s with
 * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, the value
 * of {@link Key.type} of the first key of {@link Reference.keys} shall be one of
 * {@link constants!AAS_IDENTIFIABLES}.
 *
 * Constraint `AASd-124`:
 * For external references, i.e. {@link Reference}'s with
 * {@link Reference.type} = {@link ReferenceTypes.ExternalReference}, the last
 * key of {@link Reference.keys} shall be either one of
 * {@link constants!GENERIC_GLOBALLY_IDENTIFIABLES} or one of
 * {@link constants!GENERIC_FRAGMENT_KEYS}.
 *
 * Constraint `AASd-125`:
 * For model references, i.e. {@link Reference}'s with
 * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, with more
 * than one key in {@link Reference.keys} the value of {@link Key.type}
 * of each of the keys following the first
 * key of {@link Reference.keys} shall be one of {@link constants!FRAGMENT_KEYS}.
 *
 * **Note**:
 * Constraint AASd-125 ensures that the shortest path is used.
 *
 * Constraint `AASd-126`:
 * For model references, i.e. {@link Reference}'s with
 * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, with more
 * than one key in {@link Reference.keys} the value of {@link Key.type}
 * of the last key in the reference key chain may be
 * one of {@link constants!GENERIC_FRAGMENT_KEYS} or no key at all
 * shall have a value out of {@link constants!GENERIC_FRAGMENT_KEYS}.
 *
 * Constraint `AASd-127`:
 * For model references, i.e. {@link Reference}'s with
 * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, with more
 * than one key in {@link Reference.keys} a key with {@link Key.type}
 * {@link KeyTypes.FragmentReference} shall be preceded by a key with
 * {@link Key.type} {@link KeyTypes.File} or {@link KeyTypes.Blob}. All other
 * AAS fragments, i.e. {@link Key.type} values
 * out of {@link constants!AAS_SUBMODEL_ELEMENTS_AS_KEYS}, do not support fragments.
 *
 * **Note**:
 * Which kind of fragments are supported depends on the content type and the
 * specification of allowed fragment identifiers for the corresponding resource
 * being referenced via the reference.
 *
 * Constraint `AASd-128`:
 * For model references, i.e. {@link Reference}'s with
 * {@link Reference.type} = {@link ReferenceTypes.ModelReference}, the
 * {@link Key.value} of a {@link Key} preceded by a {@link Key} with
 * {@link Key.type} = {@link KeyTypes.SubmodelElementList} is an integer
 * number denoting the position in the array of the submodel element list.
 */
export declare class Reference extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Type of the reference.
     *
     * @remarks
     * Denotes, whether reference is an external reference or a model reference.
     */
    type: ReferenceTypes;
    /**
     * {@link IHasSemantics.semanticId} of the referenced model element
     * ({@link type} = {@link ReferenceTypes.ModelReference}).
     *
     * @remarks
     * For external references there typically is no semantic ID.
     *
     * **Note**:
     * It is recommended to use a external reference.
     */
    referredSemanticId: Reference | null;
    /**
     * Unique references in their name space.
     */
    keys: Array<Key>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(type: ReferenceTypes, keys: Array<Key>, referredSemanticId?: Reference | null);
}
/**
 * A key is a reference to an element by its ID.
 */
export declare class Key extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Denotes which kind of entity is referenced.
     *
     * @remarks
     * In case {@link type} = {@link KeyTypes.GlobalReference},
     * the key represents a reference to a source that can be globally identified.
     *
     * In case {@link type} = {@link KeyTypes.FragmentReference} the key represents
     * a bookmark or a similar local identifier within its parent element as specified
     * by the key that precedes this key.
     *
     * In all other cases the key references a model element of the same or of another AAS.
     * The name of the model element is explicitly listed.
     */
    type: KeyTypes;
    /**
     * The key value, for example an IRDI or an URI
     */
    value: string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(type: KeyTypes, value: string);
}
/**
 * Enumeration of different key value types within a key.
 */
export declare enum KeyTypes {
    AnnotatedRelationshipElement = 0,
    AssetAdministrationShell = 1,
    BasicEventElement = 2,
    Blob = 3,
    Capability = 4,
    ConceptDescription = 5,
    /**
     * Data element.
     *
     * @remarks
     *
     * **Note**:
     * Data Element is abstract, *i.e.* if a key uses {@link DataElement}
     * the reference may be a Property, a File etc.
     */
    DataElement = 6,
    Entity = 7,
    /**
     * Event.
     *
     * @remarks
     *
     * **Note**:
     * {@link IEventElement} is abstract.
     */
    EventElement = 8,
    File = 9,
    /**
     * Bookmark or a similar local identifier of a subordinate part of
     * a primary resource
     */
    FragmentReference = 10,
    GlobalReference = 11,
    /**
     * Identifiable.
     *
     * @remarks
     *
     * **Note**:
     * Identifiable is abstract, i.e. if a key uses “Identifiable” the reference
     * may be an Asset Administration Shell, a Submodel or a Concept Description.
     */
    Identifiable = 12,
    /**
     * Property with a value that can be provided in multiple languages
     */
    MultiLanguageProperty = 13,
    Operation = 14,
    Property = 15,
    /**
     * Range with min and max
     */
    Range = 16,
    Referable = 17,
    /**
     * Reference
     */
    ReferenceElement = 18,
    /**
     * Relationship
     */
    RelationshipElement = 19,
    Submodel = 20,
    /**
     * Submodel Element
     *
     * @remarks
     *
     * **Note**:
     * Submodel Element is abstract, *i.e.* if a key uses {@link SubmodelElement}
     * the reference may be a {@link Property}, an {@link Operation} etc.
     */
    SubmodelElement = 21,
    /**
     * Struct of Submodel Elements
     */
    SubmodelElementCollection = 22,
    /**
     * List of Submodel Elements
     */
    SubmodelElementList = 23
}
/**
 * Iterate over the literals of {@link KeyTypes}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overKeyTypes(): IterableIterator<KeyTypes>;
/**
 * Enumeration listing all XSD anySimpleTypes
 */
export declare enum DataTypeDefXsd {
    AnyUri = 0,
    Base64Binary = 1,
    Boolean = 2,
    Byte = 3,
    Date = 4,
    DateTime = 5,
    Decimal = 6,
    Double = 7,
    Duration = 8,
    Float = 9,
    GDay = 10,
    GMonth = 11,
    GMonthDay = 12,
    GYear = 13,
    GYearMonth = 14,
    HexBinary = 15,
    Int = 16,
    Integer = 17,
    Long = 18,
    NegativeInteger = 19,
    NonNegativeInteger = 20,
    NonPositiveInteger = 21,
    PositiveInteger = 22,
    Short = 23,
    String = 24,
    Time = 25,
    UnsignedByte = 26,
    UnsignedInt = 27,
    UnsignedLong = 28,
    UnsignedShort = 29
}
/**
 * Iterate over the literals of {@link DataTypeDefXsd}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overDataTypeDefXsd(): IterableIterator<DataTypeDefXsd>;
/**
 * Strings with language tags
 */
export interface IAbstractLangString extends Class {
    /**
     * Language tag conforming to BCP 47
     */
    language: string;
    /**
     * Text in the {@link language}
     */
    text: string;
}
/**
 * String with length 128 maximum and minimum 1 characters and with language tags
 */
export declare class LangStringNameType extends Class implements IAbstractLangString {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Language tag conforming to BCP 47
     */
    language: string;
    /**
     * Text in the {@link IAbstractLangString.language}
     */
    text: string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(language: string, text: string);
}
/**
 * String with length 1023 maximum and minimum 1 characters and with language tags
 */
export declare class LangStringTextType extends Class implements IAbstractLangString {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Language tag conforming to BCP 47
     */
    language: string;
    /**
     * Text in the {@link IAbstractLangString.language}
     */
    text: string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(language: string, text: string);
}
/**
 * Container for the sets of different identifiables.
 *
 * @remarks
 * **Note**:
 * w.r.t. file exchange: There is exactly one environment independent on how many
 * files the contained elements are split. If the file is split then there
 * shall be no element with the same identifier in two different files.
 */
export declare class Environment extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Asset administration shell
     */
    assetAdministrationShells: Array<AssetAdministrationShell> | null;
    /**
     * Submodel
     */
    submodels: Array<Submodel> | null;
    /**
     * Concept description
     */
    conceptDescriptions: Array<ConceptDescription> | null;
    /**
     * Yield from {@link assetAdministrationShells} if it is set, or yield nothing.
     */
    overAssetAdministrationShellsOrEmpty(): IterableIterator<AssetAdministrationShell>;
    /**
     * Yield from {@link submodels} if it is set, or yield nothing.
     */
    overSubmodelsOrEmpty(): IterableIterator<Submodel>;
    /**
     * Yield from {@link conceptDescriptions} if it is set, or yield nothing.
     */
    overConceptDescriptionsOrEmpty(): IterableIterator<ConceptDescription>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(assetAdministrationShells?: Array<AssetAdministrationShell> | null, submodels?: Array<Submodel> | null, conceptDescriptions?: Array<ConceptDescription> | null);
}
/**
 * Data specification content is part of a data specification template and defines
 * which additional attributes shall be added to the element instance that references
 * the data specification template and meta information about the template itself.
 *
 * Constraint `AASc-3a-050`:
 * If the {@link DataSpecificationIec61360} is used
 * for an element, the value of
 * {@link IHasDataSpecification.embeddedDataSpecifications}
 * shall contain the global reference to the IRI of the corresponding
 * data specification template
 * https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0
 */
export interface IDataSpecificationContent extends Class {
}
/**
 * Embed the content of a data specification.
 */
export declare class EmbeddedDataSpecification extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Actual content of the data specification
     */
    dataSpecificationContent: IDataSpecificationContent;
    /**
     * Reference to the data specification
     */
    dataSpecification: Reference | null;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(dataSpecificationContent: IDataSpecificationContent, dataSpecification?: Reference | null);
}
export declare enum DataTypeIec61360 {
    /**
     * values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
     * Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
     * "31 May 1999".
     */
    Date = 0,
    /**
     * values consisting of sequence of characters but cannot be translated into other
     * languages
     */
    String = 1,
    /**
     * values containing string but shall be represented as different string in different
     * languages
     */
    StringTranslatable = 2,
    /**
     * values containing values that are measure of type INTEGER. In addition such a value
     * comes with a physical unit.
     */
    IntegerMeasure = 3,
    /**
     * values containing values of type INTEGER but are no currencies or measures
     */
    IntegerCount = 4,
    /**
     * values containing values of type INTEGER that are currencies
     */
    IntegerCurrency = 5,
    /**
     * values containing values that are measures of type REAL. In addition such a value
     * comes with a physical unit.
     */
    RealMeasure = 6,
    /**
     * values containing numbers that can be written as a terminating or non-terminating
     * decimal; a rational or irrational number but are no currencies or measures
     */
    RealCount = 7,
    /**
     * values containing values of type REAL that are currencies
     */
    RealCurrency = 8,
    /**
     * values representing truth of logic or Boolean algebra (TRUE, FALSE)
     */
    Boolean = 9,
    /**
     * values containing values of type STRING conformant to Rfc 3987
     *
     * @remarks
     *
     * **Note**:
     * In IEC61360-1 (2017) only URI is supported.
     * An IRI type allows in particular to express an URL or an URI.
     */
    Iri = 10,
    /**
     * values conforming to ISO/IEC 11179 series global identifier sequences
     *
     * @remarks
     *
     * IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.
     *
     * ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
     * is “#” while the delimiter between DI and VI is confined to “##”
     *
     * ISO29002_IRDI values are values containing a global identifier that identifies an
     * administrated item in a registry. The structure of this identifier complies with
     * identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
     * requirements specified in ISO/TS 29002-5 for an "international registration data
     * identifier" (IRDI).
     */
    Irdi = 11,
    /**
     * values containing values of type rational
     */
    Rational = 12,
    /**
     * values containing values of type rational. In addition such a value comes with a
     * physical unit.
     */
    RationalMeasure = 13,
    /**
     * values containing a time, conformant to ISO 8601:2004 but restricted to what is
     * allowed in the corresponding type in xml.
     *
     * @remarks
     *
     * Format hh:mm (ECLASS)
     *
     * Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
     * 1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
     * Universal Time (UTC).
     */
    Time = 14,
    /**
     * values containing a time, conformant to ISO 8601:2004 but restricted to what is
     * allowed in the corresponding type in xml.
     *
     * @remarks
     *
     * Format yyyy-mm-dd hh:mm (ECLASS)
     */
    Timestamp = 15,
    /**
     * values containing an address to a file. The values are of type URI and can represent
     * an absolute or relative path.
     *
     * @remarks
     *
     * **Note**:
     * IEC61360 does not support the file type.
     */
    File = 16,
    /**
     * Values containing string with any sequence of characters, using the syntax of HTML5
     * (see W3C Recommendation 28:2014)
     */
    Html = 17,
    /**
     * values containing the content of a file. Values may be binaries.
     *
     * @remarks
     *
     * HTML conformant to HTML5 is a special blob.
     *
     * In IEC61360 binary is for a sequence of bits, each bit being represented by “0” and
     * “1” only. A binary is a blob but a blob may also contain other source code.
     */
    Blob = 18
}
/**
 * Iterate over the literals of {@link DataTypeIec61360}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export declare function overDataTypeIec61360(): IterableIterator<DataTypeIec61360>;
/**
 * Value represented by up to four variants of a numeric value in a specific role:
 * `MIN`, `NOM`, `TYP` and `MAX`. True means that the value is available,
 * false means the value is not available.
 *
 * @remarks
 * EXAMPLE from [IEC61360-1]: In the case of having a property which is
 * of the LEVEL_TYPE min/max − expressing a range − only those two values
 * need to be provided.
 *
 * **Note**:
 * This is how AAS deals with the following combinations of level types:
 *
 * * Either all attributes are false. In this case the concept is mapped
 *   to a {@link Property} and level type is ignored.
 * * At most one of the attributes is set to true. In this case
 *   the concept is mapped to a {@link Property}.
 * * Min and max are set to true. In this case the concept is mapped
 *   to a {@link Range}.
 * * More than one attribute is set to true but not min and max only
 *   (see second case). In this case the concept is mapped
 *   to a {@link SubmodelElementCollection} with the corresponding
 *   number of Properties.
 *   Example: If attribute {@link LevelType.min} and {@link LevelType.nom} are set to true
 *   then the concept is mapped to a {@link SubmodelElementCollection}
 *   with two Properties within: min and nom.
 *   The data type of both Properties is the same.
 *
 * **Note**:
 * In the cases 2. and 4. the {@link Property.semanticId} of the Property
 * or Properties within the {@link SubmodelElementCollection} needs to include
 * information about the level type. Otherwise, the semantics is not described
 * in a unique way. Please refer to the specification.
 */
export declare class LevelType extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Minimum of the value
     */
    min: boolean;
    /**
     * Nominal value (value as designated)
     */
    nom: boolean;
    /**
     * Value as typically present
     */
    typ: boolean;
    /**
     * Maximum of the value
     */
    max: boolean;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(min: boolean, nom: boolean, typ: boolean, max: boolean);
}
/**
 * A value reference pair within a value list. Each value has a global unique id
 * defining its semantic.
 */
export declare class ValueReferencePair extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * The value of the referenced concept definition of the value in {@link valueId}.
     */
    value: string;
    /**
     * Global unique id of the value.
     *
     * @remarks
     * **Note**:
     * It is recommended to use a global reference.
     */
    valueId: Reference;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(value: string, valueId: Reference);
}
/**
 * A set of value reference pairs.
 */
export declare class ValueList extends Class {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * A pair of a value together with its global unique id.
     */
    valueReferencePairs: Array<ValueReferencePair>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(valueReferencePairs: Array<ValueReferencePair>);
}
/**
 * String with length 255 maximum and minimum 1 characters and with language tags
 *
 * @remarks
 * **Note**:
 * It is advised to keep the length of the name limited to 35 characters.
 */
export declare class LangStringPreferredNameTypeIec61360 extends Class implements IAbstractLangString {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Language tag conforming to BCP 47
     */
    language: string;
    /**
     * Text in the {@link IAbstractLangString.language}
     */
    text: string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(language: string, text: string);
}
/**
 * String with length 18 maximum and minimum 1 characters and with language tags
 */
export declare class LangStringShortNameTypeIec61360 extends Class implements IAbstractLangString {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Language tag conforming to BCP 47
     */
    language: string;
    /**
     * Text in the {@link IAbstractLangString.language}
     */
    text: string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(language: string, text: string);
}
/**
 * String with length 1023 maximum and minimum 1 characters and with language tags
 */
export declare class LangStringDefinitionTypeIec61360 extends Class implements IAbstractLangString {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Language tag conforming to BCP 47
     */
    language: string;
    /**
     * Text in the {@link IAbstractLangString.language}
     */
    text: string;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(language: string, text: string);
}
/**
 * Content of data specification template for concept descriptions for properties,
 * values and value lists conformant to IEC 61360.
 *
 * @remarks
 * **Note**:
 * IEC61360 requires also a globally unique identifier for a concept
 * description. This ID is not part of the data specification template.
 * Instead the {@link ConceptDescription.id} as inherited via
 * {@link IIdentifiable} is used. Same holds for administrative
 * information like the version and revision.
 *
 * **Note**:
 * {@link ConceptDescription.idShort} and {@link DataSpecificationIec61360.shortName} are very
 * similar. However, in this case the decision was to add
 * {@link DataSpecificationIec61360.shortName} explicitly to the data specification. Same holds for
 * {@link ConceptDescription.displayName} and
 * {@link DataSpecificationIec61360.preferredName}. Same holds for
 * {@link ConceptDescription.description} and {@link DataSpecificationIec61360.definition}.
 *
 * Constraint `AASc-3a-010`:
 * If {@link DataSpecificationIec61360.value} is not empty then {@link DataSpecificationIec61360.valueList} shall be empty
 * and vice versa.
 *
 * **Note**:
 * It is also possible that both {@link DataSpecificationIec61360.value} and {@link DataSpecificationIec61360.valueList} are
 * empty. This is the case for concept descriptions that define the semantics
 * of a property but do not have an enumeration ({@link DataSpecificationIec61360.valueList}) as
 * data type.
 *
 * **Note**:
 * Although it is possible to define a {@link ConceptDescription} for a
 * :attr:´value_list`,
 * it is not possible to reuse this {@link DataSpecificationIec61360.valueList}.
 * It is only possible to directly add a {@link DataSpecificationIec61360.valueList} as data type
 * to a specific semantic definition of a property.
 *
 * Constraint `AASc-3a-009`:
 * If {@link DataSpecificationIec61360.dataType} one of:
 * {@link DataTypeIec61360.IntegerMeasure},
 * {@link DataTypeIec61360.RealMeasure},
 * {@link DataTypeIec61360.RationalMeasure},
 * {@link DataTypeIec61360.IntegerCurrency},
 * {@link DataTypeIec61360.RealCurrency}, then {@link DataSpecificationIec61360.unit} or
 * {@link DataSpecificationIec61360.unitId} shall be defined.
 */
export declare class DataSpecificationIec61360 extends Class implements IDataSpecificationContent {
    /**
     * Indicate the runtime model type of the instance.
     */
    modelType(): ModelType;
    /**
     * Preferred name
     *
     * @remarks
     * **Note**:
     * It is advised to keep the length of the name limited to 35 characters.
     *
     * Constraint `AASc-3a-002`:
     * {@link preferredName} shall be provided at least in English.
     */
    preferredName: Array<LangStringPreferredNameTypeIec61360>;
    /**
     * Short name
     */
    shortName: Array<LangStringShortNameTypeIec61360> | null;
    /**
     * Unit
     */
    unit: string | null;
    /**
     * Unique unit id
     *
     * @remarks
     * {@link unit} and {@link unitId} need to be consistent if both attributes
     * are set
     *
     * **Note**:
     * It is recommended to use an external reference ID.
     */
    unitId: Reference | null;
    /**
     * Source of definition
     */
    sourceOfDefinition: string | null;
    /**
     * Symbol
     */
    symbol: string | null;
    /**
     * Data Type
     */
    dataType: DataTypeIec61360 | null;
    /**
     * Definition in different languages
     */
    definition: Array<LangStringDefinitionTypeIec61360> | null;
    /**
     * Value Format
     *
     * @remarks
     * **Note**:
     * The value format is based on ISO 13584-42 and IEC 61360-2.
     */
    valueFormat: string | null;
    /**
     * List of allowed values
     */
    valueList: ValueList | null;
    /**
     * Value
     */
    value: string | null;
    /**
     * Set of levels.
     */
    levelType: LevelType | null;
    /**
     * Yield from {@link shortName} if it is set, or yield nothing.
     */
    overShortNameOrEmpty(): IterableIterator<LangStringShortNameTypeIec61360>;
    /**
     * Yield from {@link definition} if it is set, or yield nothing.
     */
    overDefinitionOrEmpty(): IterableIterator<LangStringDefinitionTypeIec61360>;
    /**
     * Iterate over the instances referenced from this instance.
     *
     * We do not recurse into the referenced instances.
     *
     * @returns Iterator over the referenced instances
     */
    descendOnce(): IterableIterator<Class>;
    /**
     * Iterate recursively over the instances referenced from this instance.
     *
     * @returns Iterator over the referenced instances
     */
    descend(): IterableIterator<Class>;
    /**
     * Dispatch `visitor` on this instance.
     *
     * @param visitor - to visit this instance
     */
    accept(visitor: AbstractVisitor): void;
    /**
     * Dispatch `visitor` with `context` on this instance.
     *
     * @param visitor - to visit this instance
     * @param context - to be passed along to the dispatched visitor method
     * @typeParam ContextT - type of the context
     */
    acceptWithContext<ContextT>(visitor: AbstractVisitorWithContext<ContextT>, context: ContextT): void;
    /**
     * Dispatch the `transformer` on this instance.
     *
     * @param transformer - to transform this instance
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     */
    transform<T>(transformer: AbstractTransformer<T>): T;
    /**
     * Dispatch the `transformer` on this instance in `context`.
     *
     * @param transformer - to transform this instance
     * @param context - to be passed along to the `transformer`
     * @returns transformation of this instance
     * @paramType T - type of the transformation result
     * @paramType ContextT - type of the transformation context
     */
    transformWithContext<ContextT, T>(transformer: AbstractTransformerWithContext<ContextT, T>, context: ContextT): T;
    constructor(preferredName: Array<LangStringPreferredNameTypeIec61360>, shortName?: Array<LangStringShortNameTypeIec61360> | null, unit?: string | null, unitId?: Reference | null, sourceOfDefinition?: string | null, symbol?: string | null, dataType?: DataTypeIec61360 | null, definition?: Array<LangStringDefinitionTypeIec61360> | null, valueFormat?: string | null, valueList?: ValueList | null, value?: string | null, levelType?: LevelType | null);
}
/**
 * Visit the instances of the model.
 */
export declare abstract class AbstractVisitor {
    /**
     * Double-dispatch on `that`.
     */
    visit(that: Class): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitExtension(that: Extension): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitAdministrativeInformation(that: AdministrativeInformation): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitQualifier(that: Qualifier): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitAssetAdministrationShell(that: AssetAdministrationShell): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitAssetInformation(that: AssetInformation): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitResource(that: Resource): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitSpecificAssetId(that: SpecificAssetId): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitSubmodel(that: Submodel): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitRelationshipElement(that: RelationshipElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitSubmodelElementList(that: SubmodelElementList): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitSubmodelElementCollection(that: SubmodelElementCollection): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitProperty(that: Property): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitMultiLanguageProperty(that: MultiLanguageProperty): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitRange(that: Range): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitReferenceElement(that: ReferenceElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitBlob(that: Blob): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitFile(that: File): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitEntity(that: Entity): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitEventPayload(that: EventPayload): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitBasicEventElement(that: BasicEventElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitOperation(that: Operation): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitOperationVariable(that: OperationVariable): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitCapability(that: Capability): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitConceptDescription(that: ConceptDescription): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitReference(that: Reference): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitKey(that: Key): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitLangStringNameType(that: LangStringNameType): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitLangStringTextType(that: LangStringTextType): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitEnvironment(that: Environment): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitEmbeddedDataSpecification(that: EmbeddedDataSpecification): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitLevelType(that: LevelType): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitValueReferencePair(that: ValueReferencePair): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitValueList(that: ValueList): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitLangStringPreferredNameTypeIec61360(that: LangStringPreferredNameTypeIec61360): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitLangStringShortNameTypeIec61360(that: LangStringShortNameTypeIec61360): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitLangStringDefinitionTypeIec61360(that: LangStringDefinitionTypeIec61360): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    abstract visitDataSpecificationIec61360(that: DataSpecificationIec61360): void;
}
/**
 * Visit the instances of the model with context.
 *
 * @typeParam ContextT - type of the visitation context
 */
export declare abstract class AbstractVisitorWithContext<ContextT> {
    /**
     * Double-dispatch on `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitWithContext(that: Class, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitExtensionWithContext(that: Extension, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitAdministrativeInformationWithContext(that: AdministrativeInformation, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitQualifierWithContext(that: Qualifier, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitAssetAdministrationShellWithContext(that: AssetAdministrationShell, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitAssetInformationWithContext(that: AssetInformation, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitResourceWithContext(that: Resource, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitSpecificAssetIdWithContext(that: SpecificAssetId, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitSubmodelWithContext(that: Submodel, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitRelationshipElementWithContext(that: RelationshipElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitSubmodelElementListWithContext(that: SubmodelElementList, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitSubmodelElementCollectionWithContext(that: SubmodelElementCollection, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitPropertyWithContext(that: Property, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitMultiLanguagePropertyWithContext(that: MultiLanguageProperty, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitRangeWithContext(that: Range, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitReferenceElementWithContext(that: ReferenceElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitBlobWithContext(that: Blob, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitFileWithContext(that: File, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitAnnotatedRelationshipElementWithContext(that: AnnotatedRelationshipElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitEntityWithContext(that: Entity, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitEventPayloadWithContext(that: EventPayload, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitBasicEventElementWithContext(that: BasicEventElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitOperationWithContext(that: Operation, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitOperationVariableWithContext(that: OperationVariable, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitCapabilityWithContext(that: Capability, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitConceptDescriptionWithContext(that: ConceptDescription, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitReferenceWithContext(that: Reference, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitKeyWithContext(that: Key, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitLangStringNameTypeWithContext(that: LangStringNameType, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitLangStringTextTypeWithContext(that: LangStringTextType, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitEnvironmentWithContext(that: Environment, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitEmbeddedDataSpecificationWithContext(that: EmbeddedDataSpecification, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitLevelTypeWithContext(that: LevelType, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitValueReferencePairWithContext(that: ValueReferencePair, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitValueListWithContext(that: ValueList, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitLangStringPreferredNameTypeIec61360WithContext(that: LangStringPreferredNameTypeIec61360, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitLangStringShortNameTypeIec61360WithContext(that: LangStringShortNameTypeIec61360, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitLangStringDefinitionTypeIec61360WithContext(that: LangStringDefinitionTypeIec61360, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    abstract visitDataSpecificationIec61360WithContext(that: DataSpecificationIec61360, context: ContextT): void;
}
/**
 * Visit the instances of the model without action.
 *
 * @remarks
 * This visitor is not meant to be directly used. Instead, you usually
 * inherit from it, and implement only the relevant visit methods.
 */
export declare class PassThroughVisitor extends AbstractVisitor {
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitExtension(that: Extension): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitAdministrativeInformation(that: AdministrativeInformation): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitQualifier(that: Qualifier): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitAssetAdministrationShell(that: AssetAdministrationShell): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitAssetInformation(that: AssetInformation): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitResource(that: Resource): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitSpecificAssetId(that: SpecificAssetId): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitSubmodel(that: Submodel): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitRelationshipElement(that: RelationshipElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitSubmodelElementList(that: SubmodelElementList): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitSubmodelElementCollection(that: SubmodelElementCollection): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitProperty(that: Property): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitMultiLanguageProperty(that: MultiLanguageProperty): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitRange(that: Range): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitReferenceElement(that: ReferenceElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitBlob(that: Blob): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitFile(that: File): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitEntity(that: Entity): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitEventPayload(that: EventPayload): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitBasicEventElement(that: BasicEventElement): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitOperation(that: Operation): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitOperationVariable(that: OperationVariable): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitCapability(that: Capability): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitConceptDescription(that: ConceptDescription): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitReference(that: Reference): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitKey(that: Key): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitLangStringNameType(that: LangStringNameType): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitLangStringTextType(that: LangStringTextType): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitEnvironment(that: Environment): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitEmbeddedDataSpecification(that: EmbeddedDataSpecification): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitLevelType(that: LevelType): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitValueReferencePair(that: ValueReferencePair): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitValueList(that: ValueList): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitLangStringPreferredNameTypeIec61360(that: LangStringPreferredNameTypeIec61360): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitLangStringShortNameTypeIec61360(that: LangStringShortNameTypeIec61360): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitLangStringDefinitionTypeIec61360(that: LangStringDefinitionTypeIec61360): void;
    /**
     * Visit `that`.
     *
     * @param that - instance to be visited
     */
    visitDataSpecificationIec61360(that: DataSpecificationIec61360): void;
}
/**
 * Visit the instances of the model without action and in context.
 *
 * @remarks
 * This visitor is not meant to be directly used. Instead, you usually
 * inherit from it, and implement only the relevant visit methods.
 */
export declare class PassThroughVisitorWithContext<ContextT> extends AbstractVisitorWithContext<ContextT> {
    /**
     * Double-dispatch on `that` in `context`.
     */
    visitWithContext(that: Class, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitExtensionWithContext(that: Extension, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitAdministrativeInformationWithContext(that: AdministrativeInformation, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitQualifierWithContext(that: Qualifier, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitAssetAdministrationShellWithContext(that: AssetAdministrationShell, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitAssetInformationWithContext(that: AssetInformation, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitResourceWithContext(that: Resource, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitSpecificAssetIdWithContext(that: SpecificAssetId, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitSubmodelWithContext(that: Submodel, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitRelationshipElementWithContext(that: RelationshipElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitSubmodelElementListWithContext(that: SubmodelElementList, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitSubmodelElementCollectionWithContext(that: SubmodelElementCollection, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitPropertyWithContext(that: Property, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitMultiLanguagePropertyWithContext(that: MultiLanguageProperty, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitRangeWithContext(that: Range, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitReferenceElementWithContext(that: ReferenceElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitBlobWithContext(that: Blob, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitFileWithContext(that: File, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitAnnotatedRelationshipElementWithContext(that: AnnotatedRelationshipElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitEntityWithContext(that: Entity, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitEventPayloadWithContext(that: EventPayload, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitBasicEventElementWithContext(that: BasicEventElement, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitOperationWithContext(that: Operation, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitOperationVariableWithContext(that: OperationVariable, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitCapabilityWithContext(that: Capability, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitConceptDescriptionWithContext(that: ConceptDescription, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitReferenceWithContext(that: Reference, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitKeyWithContext(that: Key, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitLangStringNameTypeWithContext(that: LangStringNameType, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitLangStringTextTypeWithContext(that: LangStringTextType, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitEnvironmentWithContext(that: Environment, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitEmbeddedDataSpecificationWithContext(that: EmbeddedDataSpecification, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitLevelTypeWithContext(that: LevelType, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitValueReferencePairWithContext(that: ValueReferencePair, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitValueListWithContext(that: ValueList, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitLangStringPreferredNameTypeIec61360WithContext(that: LangStringPreferredNameTypeIec61360, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitLangStringShortNameTypeIec61360WithContext(that: LangStringShortNameTypeIec61360, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitLangStringDefinitionTypeIec61360WithContext(that: LangStringDefinitionTypeIec61360, context: ContextT): void;
    /**
     * Visit `that` in `context`.
     *
     * @param that - instance to be visited
     * @param context - of the visitation
     */
    visitDataSpecificationIec61360WithContext(that: DataSpecificationIec61360, context: ContextT): void;
}
/**
 * Transform the instance of the model.
 *
 * @typeParam T - type of the transformation result
 */
export declare abstract class AbstractTransformer<T> {
    /**
     * Double-dispatch on `that`.
     */
    transform(that: Class): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformExtension(that: Extension): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformAdministrativeInformation(that: AdministrativeInformation): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformQualifier(that: Qualifier): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformAssetAdministrationShell(that: AssetAdministrationShell): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformAssetInformation(that: AssetInformation): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformResource(that: Resource): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformSpecificAssetId(that: SpecificAssetId): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformSubmodel(that: Submodel): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformRelationshipElement(that: RelationshipElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformSubmodelElementList(that: SubmodelElementList): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformSubmodelElementCollection(that: SubmodelElementCollection): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformProperty(that: Property): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformMultiLanguageProperty(that: MultiLanguageProperty): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformRange(that: Range): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformReferenceElement(that: ReferenceElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformBlob(that: Blob): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformFile(that: File): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformEntity(that: Entity): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformEventPayload(that: EventPayload): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformBasicEventElement(that: BasicEventElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformOperation(that: Operation): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformOperationVariable(that: OperationVariable): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformCapability(that: Capability): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformConceptDescription(that: ConceptDescription): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformReference(that: Reference): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformKey(that: Key): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformLangStringNameType(that: LangStringNameType): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformLangStringTextType(that: LangStringTextType): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformEnvironment(that: Environment): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformEmbeddedDataSpecification(that: EmbeddedDataSpecification): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformLevelType(that: LevelType): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformValueReferencePair(that: ValueReferencePair): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformValueList(that: ValueList): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformLangStringPreferredNameTypeIec61360(that: LangStringPreferredNameTypeIec61360): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformLangStringShortNameTypeIec61360(that: LangStringShortNameTypeIec61360): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformLangStringDefinitionTypeIec61360(that: LangStringDefinitionTypeIec61360): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    abstract transformDataSpecificationIec61360(that: DataSpecificationIec61360): T;
}
/**
 * Transform the instances of the model in context.
 *
 * @typeParam ContextT - type of the transformation context
 * @typeParam T - type of the transformation result
 */
export declare abstract class AbstractTransformerWithContext<ContextT, T> {
    /**
     * Double-dispatch on `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    transformWithContext(that: Class, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformExtensionWithContext(that: Extension, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformAdministrativeInformationWithContext(that: AdministrativeInformation, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformQualifierWithContext(that: Qualifier, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformAssetAdministrationShellWithContext(that: AssetAdministrationShell, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformAssetInformationWithContext(that: AssetInformation, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformResourceWithContext(that: Resource, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformSpecificAssetIdWithContext(that: SpecificAssetId, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformSubmodelWithContext(that: Submodel, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformRelationshipElementWithContext(that: RelationshipElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformSubmodelElementListWithContext(that: SubmodelElementList, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformSubmodelElementCollectionWithContext(that: SubmodelElementCollection, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformPropertyWithContext(that: Property, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformMultiLanguagePropertyWithContext(that: MultiLanguageProperty, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformRangeWithContext(that: Range, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformReferenceElementWithContext(that: ReferenceElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformBlobWithContext(that: Blob, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformFileWithContext(that: File, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformAnnotatedRelationshipElementWithContext(that: AnnotatedRelationshipElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformEntityWithContext(that: Entity, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformEventPayloadWithContext(that: EventPayload, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformBasicEventElementWithContext(that: BasicEventElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformOperationWithContext(that: Operation, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformOperationVariableWithContext(that: OperationVariable, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformCapabilityWithContext(that: Capability, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformConceptDescriptionWithContext(that: ConceptDescription, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformReferenceWithContext(that: Reference, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformKeyWithContext(that: Key, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformLangStringNameTypeWithContext(that: LangStringNameType, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformLangStringTextTypeWithContext(that: LangStringTextType, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformEnvironmentWithContext(that: Environment, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformEmbeddedDataSpecificationWithContext(that: EmbeddedDataSpecification, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformLevelTypeWithContext(that: LevelType, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformValueReferencePairWithContext(that: ValueReferencePair, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformValueListWithContext(that: ValueList, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformLangStringPreferredNameTypeIec61360WithContext(that: LangStringPreferredNameTypeIec61360, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformLangStringShortNameTypeIec61360WithContext(that: LangStringShortNameTypeIec61360, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformLangStringDefinitionTypeIec61360WithContext(that: LangStringDefinitionTypeIec61360, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the transformation
     * @returns transformed `that`
     */
    abstract transformDataSpecificationIec61360WithContext(that: DataSpecificationIec61360, context: ContextT): T;
}
/**
 * Transform the instances of the model.
 *
 * @remarks
 * If you do not override the transformation methods, they simply
 * return {@link defaultResult}.
 *
 * @typeParam T - type of the transformation result
 */
export declare class TransformerWithDefault<T> extends AbstractTransformer<T> {
    /**
     * Default value which is returned if no override of the transformation
     */
    defaultResult: T;
    /**
     * Initialize with the given `default` value.
     *
     * @param defaultResult - returned if no override of the transformation
     */
    constructor(defaultResult: T);
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformExtension(that: Extension): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformAdministrativeInformation(that: AdministrativeInformation): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformQualifier(that: Qualifier): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformAssetAdministrationShell(that: AssetAdministrationShell): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformAssetInformation(that: AssetInformation): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformResource(that: Resource): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformSpecificAssetId(that: SpecificAssetId): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformSubmodel(that: Submodel): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformRelationshipElement(that: RelationshipElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformSubmodelElementList(that: SubmodelElementList): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformSubmodelElementCollection(that: SubmodelElementCollection): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformProperty(that: Property): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformMultiLanguageProperty(that: MultiLanguageProperty): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformRange(that: Range): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformReferenceElement(that: ReferenceElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformBlob(that: Blob): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformFile(that: File): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformAnnotatedRelationshipElement(that: AnnotatedRelationshipElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformEntity(that: Entity): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformEventPayload(that: EventPayload): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformBasicEventElement(that: BasicEventElement): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformOperation(that: Operation): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformOperationVariable(that: OperationVariable): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformCapability(that: Capability): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformConceptDescription(that: ConceptDescription): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformReference(that: Reference): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformKey(that: Key): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformLangStringNameType(that: LangStringNameType): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformLangStringTextType(that: LangStringTextType): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformEnvironment(that: Environment): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformEmbeddedDataSpecification(that: EmbeddedDataSpecification): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformLevelType(that: LevelType): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformValueReferencePair(that: ValueReferencePair): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformValueList(that: ValueList): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformLangStringPreferredNameTypeIec61360(that: LangStringPreferredNameTypeIec61360): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformLangStringShortNameTypeIec61360(that: LangStringShortNameTypeIec61360): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformLangStringDefinitionTypeIec61360(that: LangStringDefinitionTypeIec61360): T;
    /**
     * Transform `that`.
     *
     * @param that - instance to be transformed
     * @returns transformed `that`
     */
    transformDataSpecificationIec61360(that: DataSpecificationIec61360): T;
}
/**
 * Transform the instances of the model in context.
 *
 * @remarks
 * If you do not override the transformation methods, they simply
 * return {@link defaultResult}.
 *
 * @typeParam ContextT - type of the visitation context
 * @typeParam T - type of the transformation result
 */
export declare class TransformerWithDefaultAndContext<ContextT, T> extends AbstractTransformerWithContext<ContextT, T> {
    /**
     * Default value which is returned if no override of the transformation
     */
    defaultResult: T;
    /**
     * Initialize with the given `default` value.
     *
     * @param defaultResult - returned if no override of the transformation
     */
    constructor(defaultResult: T);
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformExtensionWithContext(that: Extension, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformAdministrativeInformationWithContext(that: AdministrativeInformation, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformQualifierWithContext(that: Qualifier, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformAssetAdministrationShellWithContext(that: AssetAdministrationShell, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformAssetInformationWithContext(that: AssetInformation, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformResourceWithContext(that: Resource, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformSpecificAssetIdWithContext(that: SpecificAssetId, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformSubmodelWithContext(that: Submodel, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformRelationshipElementWithContext(that: RelationshipElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformSubmodelElementListWithContext(that: SubmodelElementList, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformSubmodelElementCollectionWithContext(that: SubmodelElementCollection, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformPropertyWithContext(that: Property, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformMultiLanguagePropertyWithContext(that: MultiLanguageProperty, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformRangeWithContext(that: Range, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformReferenceElementWithContext(that: ReferenceElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformBlobWithContext(that: Blob, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformFileWithContext(that: File, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformAnnotatedRelationshipElementWithContext(that: AnnotatedRelationshipElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformEntityWithContext(that: Entity, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformEventPayloadWithContext(that: EventPayload, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformBasicEventElementWithContext(that: BasicEventElement, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformOperationWithContext(that: Operation, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformOperationVariableWithContext(that: OperationVariable, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformCapabilityWithContext(that: Capability, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformConceptDescriptionWithContext(that: ConceptDescription, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformReferenceWithContext(that: Reference, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformKeyWithContext(that: Key, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformLangStringNameTypeWithContext(that: LangStringNameType, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformLangStringTextTypeWithContext(that: LangStringTextType, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformEnvironmentWithContext(that: Environment, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformEmbeddedDataSpecificationWithContext(that: EmbeddedDataSpecification, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformLevelTypeWithContext(that: LevelType, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformValueReferencePairWithContext(that: ValueReferencePair, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformValueListWithContext(that: ValueList, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformLangStringPreferredNameTypeIec61360WithContext(that: LangStringPreferredNameTypeIec61360, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformLangStringShortNameTypeIec61360WithContext(that: LangStringShortNameTypeIec61360, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformLangStringDefinitionTypeIec61360WithContext(that: LangStringDefinitionTypeIec61360, context: ContextT): T;
    /**
     * Transform `that` in `context`.
     *
     * @param that - instance to be transformed
     * @param context - of the visitation
     * @returns transformed `that`
     */
    transformDataSpecificationIec61360WithContext(that: DataSpecificationIec61360, context: ContextT): T;
}
/**
 * Try to cast `that` instance to
 * the interface {@link IHasSemantics}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asHasSemantics(that: Class): IHasSemantics | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isHasSemantics(that: Class): that is IHasSemantics;
/**
 * Try to cast `that` instance to
 * the class {@link Extension}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asExtension(that: Class): Extension | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isExtension(that: Class): that is Extension;
/**
 * Try to cast `that` instance to
 * the interface {@link IHasExtensions}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asHasExtensions(that: Class): IHasExtensions | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isHasExtensions(that: Class): that is IHasExtensions;
/**
 * Try to cast `that` instance to
 * the interface {@link IReferable}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asReferable(that: Class): IReferable | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isReferable(that: Class): that is IReferable;
/**
 * Try to cast `that` instance to
 * the interface {@link IIdentifiable}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asIdentifiable(that: Class): IIdentifiable | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isIdentifiable(that: Class): that is IIdentifiable;
/**
 * Try to cast `that` instance to
 * the interface {@link IHasKind}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asHasKind(that: Class): IHasKind | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isHasKind(that: Class): that is IHasKind;
/**
 * Try to cast `that` instance to
 * the interface {@link IHasDataSpecification}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asHasDataSpecification(that: Class): IHasDataSpecification | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isHasDataSpecification(that: Class): that is IHasDataSpecification;
/**
 * Try to cast `that` instance to
 * the class {@link AdministrativeInformation}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asAdministrativeInformation(that: Class): AdministrativeInformation | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isAdministrativeInformation(that: Class): that is AdministrativeInformation;
/**
 * Try to cast `that` instance to
 * the interface {@link IQualifiable}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asQualifiable(that: Class): IQualifiable | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isQualifiable(that: Class): that is IQualifiable;
/**
 * Try to cast `that` instance to
 * the class {@link Qualifier}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asQualifier(that: Class): Qualifier | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isQualifier(that: Class): that is Qualifier;
/**
 * Try to cast `that` instance to
 * the class {@link AssetAdministrationShell}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asAssetAdministrationShell(that: Class): AssetAdministrationShell | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isAssetAdministrationShell(that: Class): that is AssetAdministrationShell;
/**
 * Try to cast `that` instance to
 * the class {@link AssetInformation}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asAssetInformation(that: Class): AssetInformation | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isAssetInformation(that: Class): that is AssetInformation;
/**
 * Try to cast `that` instance to
 * the class {@link Resource}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asResource(that: Class): Resource | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isResource(that: Class): that is Resource;
/**
 * Try to cast `that` instance to
 * the class {@link SpecificAssetId}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asSpecificAssetId(that: Class): SpecificAssetId | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isSpecificAssetId(that: Class): that is SpecificAssetId;
/**
 * Try to cast `that` instance to
 * the class {@link Submodel}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asSubmodel(that: Class): Submodel | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isSubmodel(that: Class): that is Submodel;
/**
 * Try to cast `that` instance to
 * the interface {@link ISubmodelElement}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asSubmodelElement(that: Class): ISubmodelElement | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isSubmodelElement(that: Class): that is ISubmodelElement;
/**
 * Try to cast `that` instance to
 * the interface {@link IRelationshipElement}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asRelationshipElement(that: Class): IRelationshipElement | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isRelationshipElement(that: Class): that is IRelationshipElement;
/**
 * Try to cast `that` instance to
 * the class {@link SubmodelElementList}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asSubmodelElementList(that: Class): SubmodelElementList | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isSubmodelElementList(that: Class): that is SubmodelElementList;
/**
 * Try to cast `that` instance to
 * the class {@link SubmodelElementCollection}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asSubmodelElementCollection(that: Class): SubmodelElementCollection | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isSubmodelElementCollection(that: Class): that is SubmodelElementCollection;
/**
 * Try to cast `that` instance to
 * the interface {@link IDataElement}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asDataElement(that: Class): IDataElement | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isDataElement(that: Class): that is IDataElement;
/**
 * Try to cast `that` instance to
 * the class {@link Property}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asProperty(that: Class): Property | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isProperty(that: Class): that is Property;
/**
 * Try to cast `that` instance to
 * the class {@link MultiLanguageProperty}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asMultiLanguageProperty(that: Class): MultiLanguageProperty | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isMultiLanguageProperty(that: Class): that is MultiLanguageProperty;
/**
 * Try to cast `that` instance to
 * the class {@link Range}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asRange(that: Class): Range | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isRange(that: Class): that is Range;
/**
 * Try to cast `that` instance to
 * the class {@link ReferenceElement}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asReferenceElement(that: Class): ReferenceElement | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isReferenceElement(that: Class): that is ReferenceElement;
/**
 * Try to cast `that` instance to
 * the class {@link Blob}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asBlob(that: Class): Blob | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isBlob(that: Class): that is Blob;
/**
 * Try to cast `that` instance to
 * the class {@link File}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asFile(that: Class): File | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isFile(that: Class): that is File;
/**
 * Try to cast `that` instance to
 * the class {@link AnnotatedRelationshipElement}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asAnnotatedRelationshipElement(that: Class): AnnotatedRelationshipElement | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isAnnotatedRelationshipElement(that: Class): that is AnnotatedRelationshipElement;
/**
 * Try to cast `that` instance to
 * the class {@link Entity}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asEntity(that: Class): Entity | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isEntity(that: Class): that is Entity;
/**
 * Try to cast `that` instance to
 * the class {@link EventPayload}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asEventPayload(that: Class): EventPayload | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isEventPayload(that: Class): that is EventPayload;
/**
 * Try to cast `that` instance to
 * the interface {@link IEventElement}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asEventElement(that: Class): IEventElement | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isEventElement(that: Class): that is IEventElement;
/**
 * Try to cast `that` instance to
 * the class {@link BasicEventElement}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asBasicEventElement(that: Class): BasicEventElement | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isBasicEventElement(that: Class): that is BasicEventElement;
/**
 * Try to cast `that` instance to
 * the class {@link Operation}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asOperation(that: Class): Operation | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isOperation(that: Class): that is Operation;
/**
 * Try to cast `that` instance to
 * the class {@link OperationVariable}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asOperationVariable(that: Class): OperationVariable | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isOperationVariable(that: Class): that is OperationVariable;
/**
 * Try to cast `that` instance to
 * the class {@link Capability}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asCapability(that: Class): Capability | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isCapability(that: Class): that is Capability;
/**
 * Try to cast `that` instance to
 * the class {@link ConceptDescription}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asConceptDescription(that: Class): ConceptDescription | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isConceptDescription(that: Class): that is ConceptDescription;
/**
 * Try to cast `that` instance to
 * the class {@link Reference}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asReference(that: Class): Reference | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isReference(that: Class): that is Reference;
/**
 * Try to cast `that` instance to
 * the class {@link Key}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asKey(that: Class): Key | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isKey(that: Class): that is Key;
/**
 * Try to cast `that` instance to
 * the interface {@link IAbstractLangString}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asAbstractLangString(that: Class): IAbstractLangString | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isAbstractLangString(that: Class): that is IAbstractLangString;
/**
 * Try to cast `that` instance to
 * the class {@link LangStringNameType}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asLangStringNameType(that: Class): LangStringNameType | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isLangStringNameType(that: Class): that is LangStringNameType;
/**
 * Try to cast `that` instance to
 * the class {@link LangStringTextType}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asLangStringTextType(that: Class): LangStringTextType | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isLangStringTextType(that: Class): that is LangStringTextType;
/**
 * Try to cast `that` instance to
 * the class {@link Environment}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asEnvironment(that: Class): Environment | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isEnvironment(that: Class): that is Environment;
/**
 * Try to cast `that` instance to
 * the interface {@link IDataSpecificationContent}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asDataSpecificationContent(that: Class): IDataSpecificationContent | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isDataSpecificationContent(that: Class): that is IDataSpecificationContent;
/**
 * Try to cast `that` instance to
 * the class {@link EmbeddedDataSpecification}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asEmbeddedDataSpecification(that: Class): EmbeddedDataSpecification | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isEmbeddedDataSpecification(that: Class): that is EmbeddedDataSpecification;
/**
 * Try to cast `that` instance to
 * the class {@link LevelType}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asLevelType(that: Class): LevelType | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isLevelType(that: Class): that is LevelType;
/**
 * Try to cast `that` instance to
 * the class {@link ValueReferencePair}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asValueReferencePair(that: Class): ValueReferencePair | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isValueReferencePair(that: Class): that is ValueReferencePair;
/**
 * Try to cast `that` instance to
 * the class {@link ValueList}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asValueList(that: Class): ValueList | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isValueList(that: Class): that is ValueList;
/**
 * Try to cast `that` instance to
 * the class {@link LangStringPreferredNameTypeIec61360}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asLangStringPreferredNameTypeIec61360(that: Class): LangStringPreferredNameTypeIec61360 | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isLangStringPreferredNameTypeIec61360(that: Class): that is LangStringPreferredNameTypeIec61360;
/**
 * Try to cast `that` instance to
 * the class {@link LangStringShortNameTypeIec61360}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asLangStringShortNameTypeIec61360(that: Class): LangStringShortNameTypeIec61360 | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isLangStringShortNameTypeIec61360(that: Class): that is LangStringShortNameTypeIec61360;
/**
 * Try to cast `that` instance to
 * the class {@link LangStringDefinitionTypeIec61360}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asLangStringDefinitionTypeIec61360(that: Class): LangStringDefinitionTypeIec61360 | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isLangStringDefinitionTypeIec61360(that: Class): that is LangStringDefinitionTypeIec61360;
/**
 * Try to cast `that` instance to
 * the class {@link DataSpecificationIec61360}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export declare function asDataSpecificationIec61360(that: Class): DataSpecificationIec61360 | null;
/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export declare function isDataSpecificationIec61360(that: Class): that is DataSpecificationIec61360;
/**
 * Check whether the type of `that` matches the type of `other` instance.
 *
 * @remarks
 * We check with `is*` function. Hence, if the class of `other` is a subclass of
 * the class of `that`, we confirm the match.
 *
 * @param that - standard instance
 * @param other - instance whose type is compared against `that`
 */
export declare function typesMatch<ClassT extends Class>(that: ClassT, other: Class): other is ClassT;
//# sourceMappingURL=types.d.ts.map